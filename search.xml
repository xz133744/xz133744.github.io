<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>报错日志：安卓插件引入和项目版本兼容问题</title>
    <url>/post/3b7f2b28.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="一、Android-Studio项目插件引入"><a href="#一、Android-Studio项目插件引入" class="headerlink" title="一、Android Studio项目插件引入"></a>一、Android Studio项目插件引入</h1><p>在引入别人的安卓文件时发生了报错</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><div class="note danger modern"><p>Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin ‘com.android.internal.application’.</p>
</div>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在<code>gradle.properties</code>添加<code>android.overridePathCheck=true</code>即可</p>
<img src="/post/3b7f2b28/1.png" class="" title="image-20230524144658745">

<img src="/post/3b7f2b28/2.png" class="" title="image-20230524144751980">

<p>引入后点击Try Again继续下载依赖包</p>
<p><img src="/post/3b7f2b28/3.png" alt="image-20230524145110593"></p>
<h1 id="二、项目版本不兼容问题"><a href="#二、项目版本不兼容问题" class="headerlink" title="二、项目版本不兼容问题"></a>二、项目版本不兼容问题</h1><p>引入插件后继续下载sdk时发生报错</p>
<div class="note danger modern"><p>The project is using an incompatible version (AGP 8.0.1) of the Android Gradle plugin. Latest supported version is AGP 7.4.2</p>
</div>

<p>意思是：</p>
<div class="note info modern"><p>使用该 “ Android Studio Dolphin “ 版本的 Android Studio , 最高只能配置的 Android Gradle 插件的版本为 7.3.1 ;</p>
</div>

<p>这是因为他用Mac 创建了该项目，而在 Mac 中创建的项目 , 自动生成的 Android Gradle 插件 版本是 7.4.2 , 说明 Mac 中项目版本号是 “ Electric Eel | 2022.1.1 “ 或者更高的版本 ;</p>
<p>将 <code>build.gradle</code> 构建脚本中的 <code>com.android.application</code> 插件 和 <code>com.android.library</code> 插件的版本修改为 <code>7.3.1</code> , 即可完成编译 ;</p>
<p>找到 <code>build.gradle</code>  :</p>
<p><img src="/post/3b7f2b28/4.png" alt="image-20230524150433874"></p>
<p>将两个版本号都修改为<code>7.3.1</code>,点击Try Again可以继续执行依赖</p>
<p><img src="/post/3b7f2b28/5.png" alt="image-20230524151121493"></p>
</font>
]]></content>
      <categories>
        <category>报错</category>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>报错</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 与 Vue2 区别</title>
    <url>/post/ec9655cc.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="Vue3-与-Vue2-区别详述"><a href="#Vue3-与-Vue2-区别详述" class="headerlink" title="Vue3 与 Vue2 区别详述"></a>Vue3 与 Vue2 区别详述</h1><h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h2><p>对于生命周期来说，整体上变化不大，只是大部分生命周期钩子名称上 + “on”，功能上是类似的。不过有一点需要注意，Vue3 在组合式API（Composition API，下面展开）中使用生命周期钩子时需要先引入，而 Vue2 在选项API（Options API）中可以直接调用生命周期钩子，如下所示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3</span></span><br><span class="line">&lt;script setup&gt;     </span><br><span class="line"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;   <span class="comment">// 使用前需引入生命周期钩子</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不会被覆盖</span></span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// vue2</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">     </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;         </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;   <span class="comment">// 直接调用生命周期钩子            </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// ...         </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,           </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>

<p>常用生命周期对比如下表所示。</p>
<table>
<thead>
<tr>
<th>vue2</th>
<th>vue3</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td></td>
</tr>
<tr>
<td>created</td>
<td></td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>mounted</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td>destroyed</td>
<td>onUnmounted</td>
</tr>
</tbody></table>
<div class="note info modern"><p>Tips： setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义。</p>
</div>

<h2 id="2-多根节点"><a href="#2-多根节点" class="headerlink" title="2. 多根节点"></a>2. 多根节点</h2><p>Vue2中，在模板中如果使用多个根节点时会报错，如下所示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// vue2中在template里存在多个根节点会报错</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">// 只能存在一个根节点，需要用一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>来包裹着</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，Vue3 支持多个根节点，也就是 fragment。即以下多根节点的写法是被允许的。根节点不再需要用<code>&lt;div&gt;</code>包裹.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Composition-API"><a href="#3-Composition-API" class="headerlink" title="3. Composition API"></a>3. Composition API</h2><p>组合式API（Composition API）是vue3最大的特色。</p>
<p>Vue2 是选项API（Options API），一个逻辑会散乱在文件不同位置（data、props、computed、watch、生命周期钩子等），导致代码的可读性变差。当需要修改某个逻辑时，需要上下来回跳转文件位置。</p>
<p>Vue3 组合式API（Composition API）则很好地解决了这个问题，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，其还提供了较为完美的逻辑复用性方案。</p>
<h2 id="4-异步组件（Suspense）"><a href="#4-异步组件（Suspense）" class="headerlink" title="4. 异步组件（Suspense）"></a>4. 异步组件（Suspense）</h2><p>Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tempalte</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">List</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        Loading...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">suspense</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Teleport"><a href="#5-Teleport" class="headerlink" title="5. Teleport"></a>5. Teleport</h2><p>Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dialogVisible = true&quot;</span>&gt;</span>显示弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;dialogVisible&quot;</span>&gt;</span></span><br><span class="line">    我是弹窗，我直接移动到了body标签下</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-响应式原理"><a href="#6-响应式原理" class="headerlink" title="6. 响应式原理"></a>6. 响应式原理</h2><p>Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。</p>
<p>Object.defineProperty 基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">// 可枚举（是否可通过 for...in 或 Object.keys() 进行访问）</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,   <span class="comment">// 可配置（是否可使用 delete 删除，是否可再次设置属性）</span></span><br><span class="line">  <span class="comment">// value: &#x27;&#x27;,   // 任意类型的值，默认undefined</span></span><br><span class="line">  <span class="comment">// writable: true,   // 可重写</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    name = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="note info modern"><p>Tips： <code>writable</code> 和 <code>value</code> 与 <code>getter</code> 和 <code>setter</code> 不共存。</p>
</div>

<p><strong>vue2核心源码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">  <span class="comment">// 一 key 一个 dep</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 key 的属性描述符，发现它是不可配置对象的话直接 return</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取 getter 和 setter，并获取 val 值</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span>((!getter || setter) &amp;&amp; <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123; val = obj[key] &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归处理，保证对象中所有 key 被观察</span></span><br><span class="line">  <span class="keyword">let</span> childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// get 劫持 obj[key] 的 进行依赖收集</span></span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span>(childOb) &#123;</span><br><span class="line">          <span class="comment">// 针对嵌套对象，依赖收集</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="comment">// 触发数组响应式</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// set 派发更新 obj[key]</span></span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(setter) &#123;</span><br><span class="line">      setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新值设置响应式</span></span><br><span class="line">    childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="comment">// 依赖通知更新</span></span><br><span class="line">    dep.<span class="title function_">notify</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p>vue2响应式的缺陷是无法监听对象或数组新增、删除的元素。</p>
</div>

<hr>
<p>vue3采用es6新特性Proxy Proxy ，通过第2个参数 handler 拦截目标对象的行为。相较于 Object.defineProperty 提供语言全范围的响应能力，消除了局限性。</p>
<p>vue3 的源码 reactive.ts 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params">target, isReadOnly, baseHandlers, collectionHandlers, proxyMap</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// collectionHandlers: 处理Map、Set、WeakMap、WeakSet</span></span><br><span class="line">  <span class="comment">// baseHandlers: 处理数组、对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-虚拟DOM"><a href="#7-虚拟DOM" class="headerlink" title="7. 虚拟DOM"></a>7. 虚拟DOM</h2><p>Vue3 相比于 Vue2，虚拟DOM上增加 patchFlag 字段。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>vue3虚拟DOM讲解<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>今天天气真不错<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染函数如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createElementVNode <span class="keyword">as</span> _createElementVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock, pushScopeId <span class="keyword">as</span> _pushScopeId, popScopeId <span class="keyword">as</span> _popScopeId &#125; <span class="keyword">from</span> vue</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_withScopeId</span> = n =&gt; (<span class="title function_">_pushScopeId</span>(scope-id),n=<span class="title function_">n</span>(),<span class="title function_">_popScopeId</span>(),n)</span><br><span class="line"><span class="keyword">const</span> _hoisted_1 = &#123; <span class="attr">id</span>: app &#125;</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(h1, <span class="literal">null</span>, vue3虚拟<span class="variable constant_">DOM</span>讲解, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"><span class="keyword">const</span> _hoisted_3 = <span class="comment">/*#__PURE__*/</span> <span class="title function_">_withScopeId</span>(<span class="function">() =&gt;</span> <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(p, <span class="literal">null</span>, 今天天气真不错, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(div, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(div, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">name</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段类型情况：1 代表节点为动态文本节点，那在 diff 过程中，只需比对文本对容，无需关注 class、style等。除此之外，发现所有的静态节点（HOISTED 为 -1），都保存为一个变量进行静态提升，可在重新渲染时直接引用，无需重新创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patchFlags 字段类型列举</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123; </span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,   <span class="comment">// 动态文本内容</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 动态类名</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 动态样式</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,   <span class="comment">// 动态属性，不包含类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,   <span class="comment">// 具有动态 key 属性，当 key 改变，需要进行完整的 diff 比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   <span class="comment">// 带有监听事件的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 不会改变子节点顺序的 fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,   <span class="comment">// 带有 key 属性的 fragment 或部分子节点</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">// 子节点没有 key 的fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 只会进行非 props 的比较</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,   <span class="comment">// 动态的插槽</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,   <span class="comment">// 静态节点，diff阶段忽略其子节点</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span>   <span class="comment">// 代表 diff 应该结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-事件缓存"><a href="#8-事件缓存" class="headerlink" title="8. 事件缓存"></a>8. 事件缓存</h2><p>了解React的同学知道，使用 React 时，性能优化的其中一点就是<strong>将事件侦听方法手动进行缓存</strong>，避免更新组件时重复创建。而 Vue3 直接替我们做了这一步。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleBtnClick&quot;</span>&gt;</span>666<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编译后的dom:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, _hoisted_1, [</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">0</span>] || (_cache[<span class="number">0</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="property">handleBtnClick</span> &amp;&amp; _ctx.<span class="title function_">handleBtnClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;666&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Diff算法优化"><a href="#9-Diff算法优化" class="headerlink" title="9.Diff算法优化"></a>9.Diff算法优化</h2><p>vue2.x中的虚拟dom是进行<strong>全量的对比</strong>，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变更好，会遍历判断virtual dom所有节点（包括一些不会变化的节点）有没有发生变化；虽然说diff算法确实减少了多DOM节点的直接操作，但是这个<strong>减少是有成本的</strong>，如果是复杂的大型项目，必然存在很复杂的父子关系的VNode,<strong>而Vue2.x的diff算法，会不断地递归调用 patchVNode，不断堆叠而成的几毫秒，最终就会造成 VNode 更新缓慢</strong>。</p>
<p>在Vue3.0中，在这个模版编译时，编译器会在动态标签末尾加上 &#x2F;* Text*&#x2F; PatchFlag。<strong>也就是在生成VNode的时候，同时打上标记，在这个基础上再进行核心的diff算法</strong>并且 PatchFlag 会标识动态的属性类型有哪些，比如这里 的TEXT 表示只有节点中的文字是动态的。而patchFlag的类型也很多,其中大致可以分为两类：</p>
<ul>
<li>当 patchFlag 的值「大于」 0 时，代表所对应的元素在 patchVNode 时或 render 时是可以被优化生成或更新的。</li>
<li>当 patchFlag 的值「小于」 0 时，代表所对应的元素在 patchVNode 时，是需要被 full diff，即进行递归遍历 VNode tree 的比较更新过程。</li>
</ul>
<h2 id="10-打包优化"><a href="#10-打包优化" class="headerlink" title="10. 打包优化"></a>10. 打包优化</h2><p>Tree-shaking：模块打包 webpack、rollup 等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。</p>
<p>以 nextTick 为例子，在 Vue2 中，全局API暴露在Vue实例上，即使未使用，也无法通过 tree-shaking 进行消除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Vue3 中针对全局和内部的API进行了重构，并考虑到 tree-shaking 的支持。因此，全局API现在只能作为ES模块构建的命名导出进行访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;   <span class="comment">// 显式导入</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一些和DOM有关的东西</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过这一更改，只要模块绑定器支持 tree-shaking，则Vue应用程序中未使用的 api 将从最终的捆绑包中消除，获得最佳文件大小。</p>
<p>受此更改影响的全局API如下所示。</p>
<ul>
<li>Vue.nextTick</li>
<li>Vue.observable （用 Vue.reactive 替换）</li>
<li>Vue.version</li>
<li>Vue.compile （仅全构建）</li>
<li>Vue.set （仅兼容构建）</li>
<li>Vue.delete （仅兼容构建）</li>
</ul>
<p>内部API也有诸如 transition、v-model 等标签或者指令被命名导出。只有在程序真正使用才会被捆绑打包。Vue3 将所有运行功能打包也只有约22.5kb，比 Vue2 轻量很多。</p>
<h2 id="11-TypeScript支持"><a href="#11-TypeScript支持" class="headerlink" title="11. TypeScript支持"></a>11. TypeScript支持</h2><p>Vue3 由 TypeScript 重写，相对于 Vue2 有更好的 TypeScript 支持。</p>
<ul>
<li>Vue2 Options API 中 option 是个简单对象，而 TypeScript 是一种类型系统，面向对象的语法，不是特别匹配。</li>
<li>Vue2 需要vue-class-component强化vue原生组件，也需要vue-property-decorator增加更多结合Vue特性的装饰器，写法比较繁琐。</li>
</ul>
</font>
]]></content>
      <categories>
        <category>vue2</category>
        <category>vue3</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>vue3</tag>
        <tag>vue2</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown图片路径问题及git bash无法中断问题</title>
    <url>/post/1d96212d.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="一、markdown图片相对路径问题"><a href="#一、markdown图片相对路径问题" class="headerlink" title="一、markdown图片相对路径问题"></a>一、markdown图片相对路径问题</h1><p>Typora本地插入图片的路径有两种方式：一个是绝对路径，一个是相对路径（相对于当前文件所在的路径）</p>
<p>Hexo通过<code>hexo-renderer-marked</code>插件实现了对markdown语法的支持，其中默认插入图片的方式为 <code>![](/images/image.jpg)</code> ，它是一个相对路径（相对于Hexo工作目录下的 <code>source</code> 文件夹）的方式。为了方便相对路径的引用，hexo提供了一个配置属性：<code>post_asset_folder</code>,在hexo根目录下的配置文件<code>_config.yml</code>中将<code>post_asset_folder</code>设置为<code>true</code> ：    </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>该功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹和一个markdown文件。例如，我使用 <code>hexo new blog</code> 创建了一篇文章 <code>blog.md</code> ，会同时在该文章文件所在的路径上创建文件夹 <code>blog/</code>，我们在该文件夹里面添加图片 <code>blog/my.png</code>，这时我们在 <code>blog.md</code> 文件中插入该图片的方式为 <code>![](my.png)</code> 就可以了。</p>
<p>这个资源文件夹名与这个文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，你可以通过相对路径来引用它们。</p>
<p>但在typora中不使用<code>![](my.png)</code>这种图片格式，typora会将其转化为<code>&#123;% asset_img my.png %&#125;</code>形式，所有在typora使用相对路径引入图片需要借助插件完成，网上大多数资料推荐的插件是<code>hexo-asset-image</code>，但我清测没有效，我使用的是<code>hexo-image-link</code>插件，是将markdown图片路径转换为asset_img语法，使得图片能够同时显示在typora和hexo上。</p>
<p>只需要两步：</p>
<h3 id="1-安装插件hexo-image-link"><a href="#1-安装插件hexo-image-link" class="headerlink" title="1.安装插件hexo-image-link"></a>1.安装插件<code>hexo-image-link</code></h3><p>根目录git bash输入命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<h3 id="2-打开Hexo资源管理配置开关"><a href="#2-打开Hexo资源管理配置开关" class="headerlink" title="2.打开Hexo资源管理配置开关"></a>2.打开Hexo资源管理配置开关</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p>展示：</p>
<p>因为我的typora设置： 格式-&gt;图像-&gt;设置图片根目录，所以我此时的引用不需要文件夹路径</p>
<p>此时我的路径是<code>/2038608.jpg</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">风景</span>](<span class="link">/2038608.jpg</span>)</span><br></pre></td></tr></table></figure>

<p>接下来你可以看到本篇博客显示如下图片：</p>
<img src="/post/1d96212d/2038608.jpg" class="" title="风景">

<h1 id="二、Git-Bash中按下Ctrl-C无法中断hexo-s的解决方法"><a href="#二、Git-Bash中按下Ctrl-C无法中断hexo-s的解决方法" class="headerlink" title="二、Git Bash中按下Ctrl+C无法中断hexo s的解决方法"></a>二、Git Bash中按下Ctrl+C无法中断hexo s的解决方法</h1><p>在git bash启动<code>hexo server</code>后经常出现ctrl+c无法关闭服务器的情况，这时我们只需要打开<code>cmd</code>，然后输入<code>taskkill /F /IM node.exe</code>，</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">taskkill</span> /F /IM node.exe</span><br></pre></td></tr></table></figure>

<p>即可关闭所有node脚本占用的端口从而关闭服务器。</p>
</font>
]]></content>
      <categories>
        <category>hexo</category>
        <category>markdown</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript实现深拷贝的3种常用方式</title>
    <url>/post/61738cb6.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="原生js中的深拷贝"><a href="#原生js中的深拷贝" class="headerlink" title="原生js中的深拷贝"></a><strong>原生js中的深拷贝</strong></h1><div class="note none blue flat"><p><strong>将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会影响到原数据 ,两个对象或数组不共享一块内存</strong></p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">     <span class="attr">abc</span>:<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">     <span class="attr">def</span>:[&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;,&#123;<span class="attr">q</span>:<span class="number">8</span>,<span class="attr">w</span>:<span class="number">9</span>&#125;],</span><br><span class="line">     <span class="attr">qwe</span>:&#123;<span class="attr">e</span>:<span class="number">4</span>,<span class="attr">f</span>:<span class="number">5</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//需求将obj这个对象拷贝出一个新对象修改新对象的值不会影响原对象的值</span></span><br><span class="line">   <span class="comment">//定义一个函数</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">copyobj</span>(<span class="params">oldobj</span>)&#123;</span><br><span class="line">     <span class="comment">//定义一个变量接收新对象</span></span><br><span class="line">     <span class="keyword">let</span> newObj=<span class="literal">null</span></span><br><span class="line">     <span class="comment">//判断这个对象还是数组</span></span><br><span class="line">     <span class="comment">//1.如果是数组 </span></span><br><span class="line">     <span class="keyword">if</span>(oldobj <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">       newObj=[]</span><br><span class="line">       oldobj.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">         newObj = <span class="title function_">copyobj</span>(item)</span><br><span class="line">       &#125;); </span><br><span class="line">       <span class="comment">//2.如果是对象</span></span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldobj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)&#123;</span><br><span class="line">       newObj=&#123;&#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> oldobj)&#123;</span><br><span class="line">        newObj[i]=<span class="title function_">copyobj</span>(oldobj[i])</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       newObj=oldobj</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">return</span> newObj</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> news=<span class="title function_">copyobj</span>(obj)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(news);</span><br></pre></td></tr></table></figure>

<h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><div class="note none blue flat"><p><strong>Object.create() 是es6新增的语法，实现的方式是通过深拷贝原型链的</strong></p>
<p><strong>Object.create</strong> <strong>: 创建一个新对象，使用现有的对象来提供新创建的对象的</strong>__proto__。</p>
</div>

<p><strong>关于new Object和Object.create的区别</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new Object() 方式创建</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;  rep : <span class="string">&#x27;apple&#x27;</span> &#125;   </span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Object</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span>,b)                			</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b.__proto__ = &quot;</span>,b.<span class="property">__proto__</span>)      	<span class="comment">// 指向Object最顶级的原型链</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b.rep = &quot;</span>,b.<span class="property">rep</span>)            		</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a===b&quot;</span>,a===b);						<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.create() 方式创建</span></span><br><span class="line"><span class="keyword">var</span> a1 = &#123; <span class="attr">rep</span>: <span class="string">&#x27;apple&#x27;</span> &#125;   </span><br><span class="line"><span class="keyword">var</span> b1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(a1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b1 = &quot;</span>,b1)  						</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b1.__proto__ = &quot;</span>,b1.<span class="property">__proto__</span>)     <span class="comment">// &#123;rep: &quot;apple&quot;&#125;  可以理解为继承一个对象, 添加的属性是在原型下。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b1.rep = &quot;</span>,b1.<span class="property">rep</span>) 			    </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a1===b1&quot;</span>,a1===b1);					<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数库-lodash，提供-cloneDeep-实现"><a href="#函数库-lodash，提供-cloneDeep-实现" class="headerlink" title="函数库 lodash，提供 cloneDeep 实现"></a>函数库 lodash，提供 cloneDeep 实现</h1><div class="note none blue flat"><p><strong>1.下载相关库</strong></p>
<p><strong>npm i –save lodash</strong></p>
<p><strong>2.在相关文件中引入</strong></p>
<p><strong>import _ from “lodash”</strong></p>
<p><strong>3.调用 _.cloneDeep() 方法实现深拷贝</strong></p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span></span><br><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> deep = _.<span class="title function_">cloneDeep</span>(objects);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deep[<span class="number">0</span>] === objects[<span class="number">0</span>]); <span class="comment">//false</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





</font>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Vercel+imsyy部署个人博客home页面</title>
    <url>/post/6b62e9ba.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>hexo</strong>框架的butterfly首页看腻了，正好发现一个好看简洁的博客首页主题<strong>imsyy</strong>，本篇博客记录我部署<strong>imsyy</strong>的过程。</p>
<h1 id="fork仓库"><a href="#fork仓库" class="headerlink" title="fork仓库"></a>fork仓库</h1><p><strong>imsyy</strong>主题是<strong>github</strong>上的开源项目，项目地址：<strong><a href="https://github.com/imsyy/home">https://github.com/imsyy/home</a></strong></p>
<a class="btn-beautify blue larger" href="https://github.com/imsyy/home" 
  title="imsyy/home"><i class="far fa-hand-point-right"></i><span>imsyy/home</span></a>

<img src="/post/6b62e9ba/1.png" class="" title="image-20230527163145711">

<p>点击<strong>fork</strong>之后添加仓库名，该项目就被复制到你的<strong>github</strong>中了</p>
<h1 id="部署vercel"><a href="#部署vercel" class="headerlink" title="部署vercel"></a>部署vercel</h1><div class="note none blue flat"><p>登录你的<strong>vercel</strong>，进入到<strong>overview</strong>页面，点击<code>Add New Project</code>创建一个新项目</p>
</div>

<img src="/post/6b62e9ba/2.png" class="" title="image-20230527163542233">

<div class="note none blue flat"><p>选择刚刚复刻的<strong>imsyy-home</strong>项目</p>
</div>

<img src="/post/6b62e9ba/3.png" class="" title="image-20230527163712714">

<div class="note none blue flat"><p>什么都不用改，直接<strong>Deploy</strong></p>
</div>

<img src="/post/6b62e9ba/4.png" class="" title="image-20230527163939159">

<div class="note none blue flat"><p>之后等待部署成功就行了</p>
</div>

<hr>
<div class="note danger flat"><p>vercel在国内会被墙，所以需要绑定一个域名来正常访问</p>
</div>

<img src="/post/6b62e9ba/5.png" class="" title="image-20230527164325263">

<div class="note none blue flat"><p>打开<strong>域名管理面板</strong>，添加<strong>域名解析</strong>，我们只需添加一个二级域名即可，<strong>主机记录</strong>为<code>imsyy</code>，可以随意设置，<strong>记录类型</strong>为<code>CNAME</code>，<strong>记录值</strong>为<code>vercel-dns.com.</code></p>
</div>

<img src="/post/6b62e9ba/6.png" class="" title="image-20230527170014755">

<div class="note none blue flat"><p>随后回到<strong>vercel</strong>中，添加域名<code>imsyy+你的域名</code>,然后等待解析完成之后就可以使用该域名访问到一个初始化的<strong>imsyy</strong>页面啦</p>
</div>

<img src="/post/6b62e9ba/7.png" class="" title="image-20230527170327736">

<hr>
<h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><h2 id="先将项目copy到本地"><a href="#先将项目copy到本地" class="headerlink" title="先将项目copy到本地"></a>先将项目copy到本地</h2><p>打开<strong>github</strong>，进入<strong>imsyy</strong>项目所在的储存库，你可以选择<code>Download ZIP</code>直接将项目下载成一个压缩包，或者复制<strong>SSH</strong>，使用<strong>git</strong>拉取整个项目</p>
<div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">直接下载压缩包</button></li><li class="tab"><button type="button" data-href="#-2">git拉取</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><div class="note none blue flat"><p>点击Download Zip下载并在本地解压打开即可</p>
</div>

<img src="/post/6b62e9ba/8.png" class="" title="image-20230527170327737"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><div class="note none blue flat"><p>复制你的SSH密钥，在你需要保存的文件根目录右键打开<code>GIT BASH</code>，输入<code>git clone 你的SSH密钥</code>即可</p>
</div>

<img src="/post/6b62e9ba/image-20230527172314585.png" class="" title="image-20230527172314585"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h2 id="打开本地预览"><a href="#打开本地预览" class="headerlink" title="打开本地预览"></a>打开本地预览</h2><div class="note none blue flat"><p>在这之前需要运行本地预览</p>
</div>



<p>本地预览需要我们在本地安装好<code>node.js</code>环境以及<code>npm包管理器</code>，随后<a href="https://so.csdn.net/so/search?q=%E5%AE%89%E8%A3%85yarn&spm=1001.2101.3001.7020">安装yarn</a>，如你的电脑已经安装过<code>yarn</code>可以跳过这一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install yarn</span><br></pre></td></tr></table></figure>

<p>安装完成后执行<code>yarn install</code>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>

<p>依赖项搞定了，用<code>dev</code>查看预览页面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn dev</span><br></pre></td></tr></table></figure>

<div class="note none blue flat"><p>默认端口是<strong>localhost:3000</strong>，浏览器打开即可预览初始化的<strong>imsyy</strong>页面</p>
</div>

<img src="/post/6b62e9ba/image-20230527173229265.png" class="" title="image-20230527173229265">

<hr>
<h1 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h1><h2 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h2><p>如果你不需要社交链接，那么你可以打开<strong>根目录：</strong><code>\src\components\SocialLinks</code>下的<code>index.vue</code>，然后将里面的<code>&lt;template&gt;</code>里的内容注释掉</p>
<img src="/post/6b62e9ba/image-20230527202035636.png" class="" title="image-20230527202035636">

<p>如果要添加或修改社交链接，那么你需要进入到<strong>根目录</strong>下的<code>public</code>文件夹中找到<code>socialLinks.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/icon/github.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;去 Github 看看&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/你的github&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BiliBili&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/icon/bilibili.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(゜-゜)つロ 干杯 ~&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://space.bilibili.com/你的哔哩哔哩账号&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;QQ&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/icon/qq.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有什么事吗&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://res.abeim.cn/api/qq/?qq=你的QQ&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Email&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/icon/email.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;来封 Email ~&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Telegram&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/images/icon/telegram.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你懂的 ~&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的Telegram地址&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>社交链接会在这里展示出来：</p>
<img src="/post/6b62e9ba/image-20230527203611490.png" class="" title="image-20230527203611490">

<h2 id="添加你的基本信息"><a href="#添加你的基本信息" class="headerlink" title="添加你的基本信息"></a>添加你的基本信息</h2><p>打开<strong>根目录</strong>下的<code>.env</code>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">VITE_SITE_NAME</span> <span class="string">=</span> <span class="string">&quot;小铭の博客&quot;</span>  <span class="comment"># 站点名称</span></span><br><span class="line"><span class="string">VITE_SITE_ANTHOR</span> <span class="string">=</span> <span class="string">&quot;小铭&quot;</span>   <span class="comment"># 站点作者</span></span><br><span class="line"><span class="string">VITE_SITE_KEYWORDS</span> <span class="string">=</span> <span class="string">&quot;小铭,个人博客&quot;</span> <span class="comment"># 站点关键词</span></span><br><span class="line"><span class="string">VITE_SITE_DES</span> <span class="string">=</span> <span class="string">&quot;一些乱七八糟的记录&quot;</span> <span class="comment"># 站点描述</span></span><br><span class="line"><span class="string">VITE_SITE_URL</span> <span class="string">=</span> <span class="string">&quot;xiaoming.site&quot;</span>  <span class="comment"># 站点地址(首页头像旁的文字)</span></span><br><span class="line"><span class="string">VITE_SITE_LOGO</span> <span class="string">=</span> <span class="string">&quot;/images/icon/ico.jpg&quot;</span> <span class="comment"># 站点 LOGO</span></span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p><font color='red' size=4>注意：</font>首页的logo字母是经过压缩的，使用其他字母会变成默认字体(只有<strong>imsyy.top</strong>和<strong>hello，world</strong>里的这些字母有样式),如果需要所有字母的样式可以去作者的<strong>github</strong>的项目首页下载</p>
<p><a class="btn-beautify blue larger" href="https://github.com/imsyy/home" 
  title="点击去下载完整字体"><i class="far fa-hand-point-right"></i><span>点击去下载完整字体</span></a></p>
</div>

<h2 id="修改建站日期"><a href="#修改建站日期" class="headerlink" title="修改建站日期"></a>修改建站日期</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建站日期</span></span><br><span class="line"><span class="comment">## 请按照 YYYY-MM-DD 格式填写</span></span><br><span class="line"><span class="string">VITE_SITE_START</span> <span class="string">=</span> <span class="string">&quot;2023-5-8&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加音乐播放器"><a href="#添加音乐播放器" class="headerlink" title="添加音乐播放器"></a>添加音乐播放器</h2><p>这里我们只需要修改歌曲服务器和播放ID就行</p>
<p>在浏览器打开你的网易云或者QQ音乐的，选择一个歌单，将网址中的id复制进来即可替换歌单</p>
<div class="note none blue flat"><p><strong>建议选择网易云，无论是国内国外，网易云的播放服务器都更稳定</strong></p>
</div>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 歌曲 API 地址</span></span><br><span class="line"><span class="comment">## 请参照 https://github.com/xizeyoupan/Meting-API#deno-deploy 进行 API 服务部署</span></span><br><span class="line"><span class="comment">## 此处提供的服务可能会超量从而无法访问，请自行部署</span></span><br><span class="line"><span class="comment">## 若使用QQ音乐歌单，歌曲数量最好不要超出50首</span></span><br><span class="line"><span class="comment">## 备用：https://api.wuenci.com/meting/api/</span></span><br><span class="line"><span class="string">VITE_SONG_API</span> <span class="string">=</span> <span class="string">&quot;https://api-meting.imsyy.top/api&quot;</span></span><br><span class="line"><span class="comment"># 歌曲服务器 ( netease-网易云, tencent-qq音乐 )</span></span><br><span class="line"><span class="string">VITE_SONG_SERVER</span> <span class="string">=</span> <span class="string">&quot;netease&quot;</span></span><br><span class="line"><span class="comment"># 播放类型 ( song-歌曲, playlist-播放列表, album-专辑, search-搜索, artist-艺术家 )</span></span><br><span class="line"><span class="string">VITE_SONG_TYPE</span> <span class="string">=</span> <span class="string">&quot;playlist&quot;</span></span><br><span class="line"><span class="comment"># 播放 ID</span></span><br><span class="line"><span class="string">VITE_SONG_ID</span> <span class="string">=</span> <span class="string">&quot;5331617474&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="简介文本"><a href="#简介文本" class="headerlink" title="简介文本"></a>简介文本</h2><p>修改首页的一些简介</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简介文本</span></span><br><span class="line"><span class="string">VITE_DESC_HELLO</span> <span class="string">=</span> <span class="string">&quot;Hello Blog !&quot;</span></span><br><span class="line"><span class="string">VITE_DESC_TEXT</span> <span class="string">=</span> <span class="string">&quot;黄师塔前江水东，春光懒困倚微风。&quot;</span></span><br><span class="line"><span class="string">VITE_DESC_HELLO_OTHER</span> <span class="string">=</span> <span class="string">&quot;less times !&quot;</span></span><br><span class="line"><span class="string">VITE_DESC_TEXT_OTHER</span> <span class="string">=</span> <span class="string">&quot;岁月不居，时节如流。&quot;</span></span><br></pre></td></tr></table></figure>

<img src="/post/6b62e9ba/image-20230527215209845.png" class="" title="image-20230527215209845">

<p>点击文本块后：</p>
<img src="/post/6b62e9ba/image-20230527215309543.png" class="" title="image-20230527215309543">

<h2 id="天气服务"><a href="#天气服务" class="headerlink" title="天气服务"></a>天气服务</h2><p>因为作者的天气服务key已经超量，建议自行前往高德开放平台注册一个<strong>key</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 天气 Key</span></span><br><span class="line"><span class="comment">## 请前往高德开放平台注册 Web服务 Key（免费的）</span></span><br><span class="line"><span class="comment">## 请各位大佬行行好，别再让我超量了</span></span><br><span class="line"><span class="string">VITE_WEATHER_KEY</span> <span class="string">=</span> <span class="string">&quot;57eaea5833ff1616cfd1ff2c4cf9b58a&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="网站顶部logo"><a href="#网站顶部logo" class="headerlink" title="网站顶部logo"></a>网站顶部logo</h2><p>网站logo需要前往<strong>根目录</strong>下的<code>index.html</code>文件的头文件处修改</p>
<p>打开<code>index.html</code>，找到<code>rel=&quot;icon&quot;</code>的<code>link</code>将<code>href</code>修改为你的头像的路径</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/images/icon/ico.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/post/6b62e9ba/image-20230527215951311.png" class="" title="image-20230527215951311">

<h2 id="footer配置"><a href="#footer配置" class="headerlink" title="footer配置"></a>footer配置</h2><p>进入<strong>根目录</strong>下的<code>src\components\Footer\index.vue</code></p>
<p>将网址链接修改为你的链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span></span></span><br><span class="line"><span class="tag">    &gt;</span>Copyright<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;copy;</span><span class="symbol">&amp;nbsp;</span>&#123;&#123; fullYear &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://xiaoming.site&quot;</span>&gt;</span>小铭<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你的站点经过了备案，修改如下字段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://beian.miit.gov.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>豫ICP备2022018134号-1&lt;/a</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h2 id="背景图设置"><a href="#背景图设置" class="headerlink" title="背景图设置"></a>背景图设置</h2><p>进入<strong>根目录</strong>下的<code>src\js\store\index.js</code></p>
<p>在这里可以修改关于壁纸的各项设置</p>
<div class="note none blue flat"><p><strong>coverType</strong>可选<code>0-4</code>,<strong>0</strong>是默认壁纸，每次刷新从<strong>根目录</strong>下的<code>public\images</code>下随机选取一张，<strong>1</strong>是<strong>bing</strong>每日推荐壁纸，<strong>2</strong>是随机风景，<strong>3</strong>是随机<strong>二刺螈</strong>背景图</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">innerWidth</span>: <span class="literal">null</span>, <span class="comment">// 当前窗口宽度</span></span><br><span class="line">            <span class="attr">coverType</span>: <span class="string">&quot;0&quot;</span>, <span class="comment">// 壁纸种类</span></span><br><span class="line">            <span class="attr">siteStartShow</span>: <span class="literal">true</span>, <span class="comment">// 建站日期显示</span></span><br><span class="line">            <span class="attr">musicIsOk</span>: <span class="literal">false</span>, <span class="comment">// 音乐是否加载完成</span></span><br><span class="line">            <span class="attr">musicVolume</span>: <span class="number">0</span>, <span class="comment">// 音乐音量;</span></span><br><span class="line">            <span class="attr">musicOpenState</span>: <span class="literal">false</span>, <span class="comment">// 音乐面板开启状态</span></span><br><span class="line">            <span class="attr">backgroundShow</span>: <span class="literal">false</span>, <span class="comment">// 壁纸展示状态</span></span><br><span class="line">            <span class="attr">boxOpenState</span>: <span class="literal">false</span>, <span class="comment">// 盒子开启状态</span></span><br><span class="line">            <span class="attr">mobileOpenState</span>: <span class="literal">false</span>, <span class="comment">// 移动端开启状态</span></span><br><span class="line">            <span class="attr">mobileFuncState</span>: <span class="literal">false</span>, <span class="comment">// 移动端功能区开启状态</span></span><br><span class="line">            <span class="attr">setOpenState</span>: <span class="literal">false</span>, <span class="comment">// 设置页面开启状态</span></span><br><span class="line">            <span class="attr">playerState</span>: <span class="literal">false</span>, <span class="comment">// 当前播放状态</span></span><br><span class="line">            <span class="attr">playerTitle</span>: <span class="literal">null</span>, <span class="comment">// 当前播放歌曲名</span></span><br><span class="line">            <span class="attr">playerArtist</span>: <span class="literal">null</span>, <span class="comment">// 当前播放歌手名</span></span><br><span class="line">            <span class="attr">playerLrc</span>: <span class="string">&quot;歌词加载中&quot;</span>, <span class="comment">// 当前播放歌词</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>背景图可以在前端直接设置，点击左侧留言，再点击时间胶囊右侧的设置按钮。</p>
<div class="note danger flat"><p>建议<strong>coverType</strong>默认为0，使用本地壁纸页面的打开速度会快很多</p>
</div>

<img src="/post/6b62e9ba/image-20230527225556592.png" class="" title="image-20230527225556592">



<div class="note none blue flat"><p>如果需要更换本地壁纸，你可以打开<strong>根目录</strong>下的<code>src\components\Background\index.vue</code></p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">changeBg</span> = (<span class="params">type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">    bgUrl.<span class="property">value</span> = <span class="string">`/images/background<span class="subst">$&#123;<span class="built_in">Math</span>.floor(</span></span></span><br><span class="line"><span class="subst"><span class="string">      <span class="built_in">Math</span>.random() * <span class="number">10</span> + <span class="number">1</span></span></span></span><br><span class="line"><span class="subst"><span class="string">    )&#125;</span>.webp`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">    bgUrl.<span class="property">value</span> = <span class="string">&quot;https://api.dujin.org/bing/1920.php&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">    bgUrl.<span class="property">value</span> = <span class="string">&quot;https://api.btstu.cn/sjbz/api.php?lx=fengjing&amp;format=images&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">    bgUrl.<span class="property">value</span> = <span class="string">&quot;https://www.dmoe.cc/random.php&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认壁纸是随机生成<strong>0-10</strong>的数，每次刷新随机抽取一张图片</p>
<p>如果你要添加壁纸，需要修改<code>Math.random() * 10 + 1</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() * 你的图片数 + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后将新壁纸到<strong>根目录</strong>下的<code>public\images</code>文件夹中，修改图片名称为<code>background$&#123;图片序号&#125;.webp</code>，这里的后缀名<code>.webp</code>根据你文件夹中的图片后缀修改</p>
<p>这里是我的图片文件夹</p>
<img src="/post/6b62e9ba/image-20230528133015854.png" class="" title="image-20230528133015854">

<h2 id="网站链接配置"><a href="#网站链接配置" class="headerlink" title="网站链接配置"></a>网站链接配置</h2><p>进入<strong>根目录</strong>下的<code>src\components\Links\index.vue</code></p>
<p>在<code>linksData</code>数组对象中增加或减少你的站点，建议不要超过六个，否则需要重设样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> linksData = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">Blog</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;博客&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://blog.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">Cloud</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;网盘&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://pan.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">CompactDisc</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;音乐&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://music.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">Compass</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;起始页&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://nav.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">Book</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;网址集&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://web.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">icon</span>: <span class="title class_">Fire</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;今日热榜&quot;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&quot;https://hot.imsyy.top/&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果你需要更改链接图标，打开<strong>根目录</strong>下的<code>node_modules\@vicons\fa\es\index.d.ts</code>，找到你需要的图标然后<code>import</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">Link</span>,</span><br><span class="line">  <span class="title class_">Blog</span>,</span><br><span class="line">  <span class="title class_">CompactDisc</span>,</span><br><span class="line">  <span class="title class_">Cloud</span>,</span><br><span class="line">  <span class="title class_">Compass</span>,</span><br><span class="line">  <span class="title class_">Book</span>,</span><br><span class="line">  <span class="title class_">Fire</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@vicons/fa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>修改一下链接地址就可以得到一个简洁好看的博客首页啦</p>
</font>
]]></content>
      <categories>
        <category>imsyy</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>imsyy</tag>
        <tag>vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序的组件间通信</title>
    <url>/post/18c75403.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note none blue flat"><p>在微信小程序的组件通信中有3种方式：</p>
</div>

<ol>
<li><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><ul>
<li>用于父组件向子组件的指定属性设置数据，但仅能设置<strong>JSON</strong>兼容的格式数据</li>
</ul>
</li>
<li><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><ul>
<li>用于子组件向父组件传递数据，可以传递任意数据</li>
</ul>
</li>
<li><h3 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h3><ul>
<li>父组件还可以通过<code>this.selectComponent()</code>获取子组件实例对象</li>
<li>这样就可以直接访问子组件的任意数据和方法</li>
</ul>
</li>
</ol>
<p>总而言之也就是父传子和子传父两种，这是核心知识但比较绕，于是写篇博客记录下方便之后的使用和记忆。</p>
<h1 id="属性绑定-父传子"><a href="#属性绑定-父传子" class="headerlink" title="属性绑定(父传子)"></a>属性绑定(父传子)</h1><h2 id="准备例子"><a href="#准备例子" class="headerlink" title="准备例子"></a>准备例子</h2><p>此时我们有一个子组件<code>test5(components)</code>和一个父组件<code>home(pages)</code>，在父组件定义了一个按钮和事件<code>bindtap()</code>,每当点击按钮时，<strong>count</strong>的值会被动态+1，现在我们需要将该<strong>count</strong>值传入子组件<code>test5</code>中，让按钮点击时两个页面的<strong>count</strong>都动态+1</p>
<p><strong>子组件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>父组件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>父组件中count值是:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>------------------------------<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-test5</span>&gt;</span><span class="tag">&lt;/<span class="name">my-test5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnAdd&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">btnAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><strong>此时页面的效果：</strong></p>
<p><img src="/post/18c75403/1.png" alt="image-20230526175003759"></p>
<p>这时候点击按钮只有父组件的<strong>count</strong>会+1，因为子组件中没有定义<strong>count</strong>这个值，我们可以通过<strong>properties</strong>结点给子组件传入<strong>count</strong></p>
<p>在<code>test5.js</code>的<strong>Component</strong>下添加<code>properties</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="title class_">Number</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>count</strong>的形式也可以为一个对象如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<strong>value</strong>是给传入的<strong>count</strong>设置一个默认值，例子中的<strong>count</strong>随父组件动态变化，不需要默认值，所以这里简写为数据类型的形式就行。</p>
<p>随后在<code>home</code>页面的组件标签中添加属性<code>count=&quot;&#123;&#123;count&#125;&#125;&quot;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>父组件中count值是:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>------------------------------<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-test5</span> <span class="attr">count</span>=<span class="string">&quot;&#123;&#123;count&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-test5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnAdd&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了父组件给子组件传值。</p>
<hr>
<h1 id="事件绑定-子传父"><a href="#事件绑定-子传父" class="headerlink" title="事件绑定(子传父)"></a>事件绑定(子传父)</h1><h2 id="准备例子-1"><a href="#准备例子-1" class="headerlink" title="准备例子"></a>准备例子</h2><p>取上述例子，将按钮和方法都移到子组件中，此时子组件中定义了<strong>count</strong>及其方法而父组件没有，我们需要将子组件的<strong>count</strong>传入父组件</p>
<div class="note danger flat"><p><font color="red" size=4>注意</font>：compnents页面的方法只能写在methods中</p>
</div>

<p>注意：</p>
<p><strong>子组件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnAdd&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">btnAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">  	<span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">  		<span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">  	&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>父组件：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>父组件中count值是:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>------------------------------<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-test5</span> <span class="attr">count</span>=<span class="string">&quot;&#123;&#123;count&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-test5</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="在父组件中js文件定义一个自定义方法syncCount-："><a href="#在父组件中js文件定义一个自定义方法syncCount-：" class="headerlink" title="在父组件中js文件定义一个自定义方法syncCount()："></a>在<font color="#c34c60">父组件</font>中<strong>js文件</strong>定义一个自定义方法<code>syncCount()</code>：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">syncCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sycnCount&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="改写父组件的wxml，添加自定义事件的函数引用："><a href="#改写父组件的wxml，添加自定义事件的函数引用：" class="headerlink" title="改写父组件的wxml，添加自定义事件的函数引用："></a>改写<font color="#c34c60">父组件</font>的<strong>wxml</strong>，添加自定义事件的函数引用：</h3><div class="note none blue flat"><p><code>bind:sync=&quot;syncCount&quot;</code>中的sync是自定义事件的名称</p>
</div>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>父组件中count值是:&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>------------------------------<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-test5</span> <span class="attr">count</span>=<span class="string">&quot;&#123;&#123;count&#125;&#125;&quot;</span> <span class="attr">bind:sync</span>=<span class="string">&quot;syncCount&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-test5</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="改写子组件的btnAdd-方法，使点击按钮触发btnAdd-的同时也触发自定义事件："><a href="#改写子组件的btnAdd-方法，使点击按钮触发btnAdd-的同时也触发自定义事件：" class="headerlink" title="改写子组件的btnAdd()方法，使点击按钮触发btnAdd()的同时也触发自定义事件："></a>改写<font color="#c34c60">子组件</font>的<code>btnAdd()</code>方法，使点击按钮触发<code>btnAdd()</code>的同时也触发自定义事件：</h3><div class="note warning no-icon flat"><p><code>this.triggerEvent()</code>可以用于调用自定义事件，形式为this.triggerEvent(‘自定义事件名称”,{ 参数对象})</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">btnAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//触发自定义事件</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;sync&#x27;</span>,&#123;<span class="attr">value</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="改写父组件的js："><a href="#改写父组件的js：" class="headerlink" title="改写父组件的js："></a>改写<font color="#c34c60">父组件</font>的<strong>js</strong>：</h3></li>
</ol>
<p>设置一个接受参数，此时控制台打印出来的<strong>e</strong>就是当前是自定义事件<strong>sync</strong>的属性,<strong>e.detail.value</strong>就是我们通过自定义事件传入父组件的值，即当前<strong>count</strong>的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">syncCount</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以将接收到的值同步到父组件的<strong>data</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">syncCount</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>:e.<span class="property">detail</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>这样就可以愉快地在父组件中使用<strong>count</strong>了</p>
<hr>
<h1 id="获取组件实例-1"><a href="#获取组件实例-1" class="headerlink" title="获取组件实例"></a>获取组件实例</h1><p>可在父组件里调用**this. selectComponent(“id或class选择器”)**，获取子组件的实例对象,从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如this.selectComponent(“.my-component”)。</p>
<p>如果只是用于传值，该方法是不常用的。所以这里不多赘述，使用一个简单的例子来展示。</p>
<h3 id="在父组件的wxml页面引用子组件，并给子组件的标签加上一个类名或一个id"><a href="#在父组件的wxml页面引用子组件，并给子组件的标签加上一个类名或一个id" class="headerlink" title="在父组件的wxml页面引用子组件，并给子组件的标签加上一个类名或一个id"></a>在父组件的wxml页面引用子组件，并给子组件的标签加上一个类名或一个id</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-test5</span> <span class="attr">class</span>=<span class="string">&quot;customA&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-test5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;getChild&quot;</span>&gt;</span>获取子组件实例<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在父组件的js文件中调用getChild"><a href="#在父组件的js文件中调用getChild" class="headerlink" title="在父组件的js文件中调用getChild()"></a>在父组件的js文件中调用getChild()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="title function_">getChild</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">//下面的参数不能选择标签选择器&#x27;my-test5&#x27;，不然返回的是null</span></span><br><span class="line">      <span class="keyword">const</span> child = <span class="variable language_">this</span>.<span class="title function_">selectComponent</span>(<span class="string">&#x27;.customA&#x27;</span>)</span><br><span class="line">      <span class="comment">// 或者</span></span><br><span class="line">      <span class="comment">// const child = this.selectComponent(&#x27;#cA&#x27;)</span></span><br><span class="line">      child.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>:child.<span class="property">data</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这样很轻松的就能获取到子组件中<strong>data</strong>的值</p>
<div class="note red icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p><font color='red' size=4>注意：</font><font color='#d67b7f'>selectComponent(‘选择器’)里的选择器只能选择类选择器和id选择器，如果选择标签选择器会返回null</font></p>
</div>

<p><strong></font></strong></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js爬虫</title>
    <url>/post/6be0da90.html</url>
    <content><![CDATA[<h1 id="一、获取网页内容"><a href="#一、获取网页内容" class="headerlink" title="一、获取网页内容"></a>一、获取网页内容</h1><p>nodejs提供了简便的方法帮助我们获取网页的整片内容。node的核心模块http模块即可发送请求，摘自node官网api:<br><strong>http.request(options[.callback])</strong><br><strong>http.request(url[,options][,callback])</strong></p>
<p>以豆瓣top250网站为例：<a href="https://movie.douban.com/top250">豆瓣电影 Top 250 (douban.com)</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line"><span class="keyword">let</span> req = https.<span class="title function_">request</span>(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunks = []</span><br><span class="line">  <span class="comment">//监听data事件，获取传递过米的数据片段</span></span><br><span class="line">  <span class="comment">//拼接数据片段</span></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">chunk</span> =&gt;</span> chunks.<span class="title function_">push</span>(chunk))</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//拼按所有的chunk,并转换成字符串</span></span><br><span class="line">    <span class="keyword">let</span> htmlStr = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks).<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(htmlStr);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>

<p>node运行，输出如下图：</p>
<img src="/post/6be0da90/image-20240103212426972.png" class="" title="image-20240103212426972">

<p>首先创建了一个 <code>https.request(url, callback)</code> 请求对象，其中 <code>url</code> 参数是请求的目标 URL，<code>callback</code> 是在请求完成后执行的回调函数。</p>
<p>在回调函数中，创建了一个空数组 <code>chunks</code>，用于存储接收到的数据片段。</p>
<p>接下来，使用 <code>res.on(&#39;data&#39;, callback)</code> 监听 ‘data’ 事件，当有新的数据片段到达时，会触发该事件，并将数据片段作为参数传递给回调函数。在回调函数中，将接收到的数据片段存储到 <code>chunks</code> 数组中。</p>
<p>继续监听 ‘end’ 事件，在所有数据片段接收完毕后触发该事件，并执行回调函数。在回调函数中，通过 <code>Buffer.concat(chunks).toString(&#39;utf-8&#39;)</code> 将接收到的所有数据片段拼接起来，并转换为 UTF-8 编码的字符串。</p>
<p>最后，调用 <code>req.end()</code> 发送请求，表示请求的发送完毕。</p>
<div class="note warning simple"><p>有 <code>req.end()</code> 发送才会终止。</p>
</div>





<h1 id="二、cheerio库解析html"><a href="#二、cheerio库解析html" class="headerlink" title="二、cheerio库解析html"></a>二、cheerio库解析html</h1><p>cheerio 是为服务器特别定制的，快速、灵活的jQuery核心实现，是jQuery的子集。</p>
<p>cheerio可以帮助我们解析HTML代码，并且可以直接使用jQuery一样的api。</p>
<p>首先需要引入cheerio库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i cheerio -S</span><br></pre></td></tr></table></figure>

<p>在上例代码的基础上，引入<code>cheerio</code>库，写一个爬取豆瓣电影名的方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://movie.douban.com/top250&#x27;</span></span><br><span class="line"><span class="keyword">let</span> req = https.<span class="title function_">request</span>(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunks = []</span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">chunk</span> =&gt;</span> chunks.<span class="title function_">push</span>(chunk))</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> htmlStr = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks).<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> $ = cheerio.<span class="title function_">load</span>(htmlStr)</span><br><span class="line">    $(<span class="string">&#x27;.item .info .hd .title&#x27;</span>).<span class="title function_">each</span>(<span class="function">(<span class="params">index, item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>($(item).<span class="title function_">text</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>

<p>Cheerio 的 <code>load</code> 方法可以将 HTML 字符串转换成一个可操作的 DOM 树，返回一个类似于 jQuery 对象的实例。用<code>$</code>接收这个jQuery对象，并用类选择器定位所要的html语句。因为网页中有多个电影名，每个电影名所在的html语句有相同的类名，所以用<code>each</code>遍历截取的html对象，用<code>.text()</code>来获取html语句里的文本。</p>
<p>语法如下：</p>
<p><code>$(selector).each(callback)</code></p>
<p>node运行，输入如下：</p>
<img src="/post/6be0da90/image-20240103225516399.png" class="" title="image-20240103225516399">



<h2 id="伪造请求头获取接口内容"><a href="#伪造请求头获取接口内容" class="headerlink" title="伪造请求头获取接口内容"></a>伪造请求头获取接口内容</h2><p>对于前后端分离的网站，截取html内容往往不能满足我们的需求，我们需要爬取网站接口里的信息。</p>
<p>以豆瓣电影网为例：<a href="https://movie.douban.com/">https://movie.douban.com/</a></p>
<img src="/post/6be0da90/image-20240104134551402.png" class="" title="image-20240104134551402">

<p>在标头处获取<strong>url</strong>和<strong>请求方式</strong>：</p>
<img src="/post/6be0da90/image-20240104134639785.png" class="" title="image-20240104134639785">

<p>下拉找到<strong>请求标头</strong>，复制其信息，可以复制到请求&#x2F;响应头转JSON工具让其转成JSON格式更方便：</p>
<img src="/post/6be0da90/image-20240104135005686.png" class="" title="image-20240104135005686">

<p>代码示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://movie.douban.com/j/search_tags?type=movie&amp;source=index&#x27;</span></span><br><span class="line"><span class="keyword">let</span> req = https.<span class="title function_">request</span>(url, &#123;<span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>, <span class="attr">headers</span>: &#123;</span><br><span class="line">  <span class="string">&quot;Accept&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Accept-Encoding&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Accept-Language&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Connection&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;viewed=&#x27;35631064&#x27;; bid=UwHXnWLpcZg; gr_user_id=bf201205-1e3a-4131-8491-88253e67fb76; __gads=ID=749f4c4931ab025b-223da8c8c8db007b:T=1679058886:RT=1679058886:S=ALNI_MZRUmjknbTk54CTIvi5s1m_3-SA7A; ll=&#x27;118303&#x27;; _vwo_uuid_v2=D52720B4D5A586B53BD688A3786124938|f87d4e04b1cd62572810de204fdd3eb5; __yadk_uid=dV04udAWkRjdUKLUIpCLx8JuGzQ4H4Ic; _pk_id.100001.4cf6=a77e2b4705c4ab5a.1680358419.; __gpi=UID=000009626405c239:T=1679058886:RT=1684638900:S=ALNI_Mb9EqpYZxZsGwCPw_b6iZflzNBXNQ; douban-fav-remind=1; Hm_lvt_16a14f3002af32bf3a75dfe352478639=1702295581; __utmc=30149280; __utmc=223695111; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1704346116%2C%22https%3A%2F%2Fcn.bing.com%2F%22%5D; _pk_ses.100001.4cf6=1; ap_v=0,6.0; __utma=30149280.988761868.1679058890.1704284347.1704346123.21; __utmb=30149280.0.10.1704346123; __utmz=30149280.1704346123.21.13.utmcsr=cn.bing.com|utmccn=(referral)|utmcmd=referral|utmcct=/; __utma=223695111.1604615225.1680358420.1704284347.1704346123.19; __utmb=223695111.0.10.1704346123; __utmz=223695111.1704346123.19.8.utmcsr=cn.bing.com|utmccn=(referral)|utmcmd=referral|utmcct=/&quot;</span>,<span class="string">&quot;Host&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Referer&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;https&quot;</span>:<span class="string">&quot;//movie.douban.com/&quot;</span>,<span class="string">&quot;Sec-Ch-Ua&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Sec-Ch-Ua-Mobile&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Sec-Ch-Ua-Platform&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Sec-Fetch-Dest&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Sec-Fetch-Mode&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;Sec-Fetch-Site&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;X-Requested-With&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">&#125;&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> chunks = []</span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">chunk</span> =&gt;</span> chunks.<span class="title function_">push</span>(chunk))</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> htmlStr = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(chunks).<span class="title function_">toString</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(htmlStr));</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure>



<div class="note warning modern"><p><code>https.request(url,(method),(headers:{}))</code>方法，<strong>method</strong>和请求头<strong>headers</strong>都是可选参数，<strong>method</strong>默认为<code>GET</code>方法</p>
</div>



<p>node输出：</p>
<img src="/post/6be0da90/image-20240104202542598.png" class="" title="image-20240104202542598">



<h1 id="三、Selenium网页自动化操作"><a href="#三、Selenium网页自动化操作" class="headerlink" title="三、Selenium网页自动化操作"></a>三、Selenium网页自动化操作</h1><p>Selenium是广泛使用的模拟浏览器运行的库，它是一个用于Web应用程序测试的工具。 Selenium测试直接运行在浏览器中，就像真正的用户在操作一样，并且支持大多数现代 Web 浏览器。下面就进入正式的学习阶段。</p>
<h2 id="下载浏览器驱动"><a href="#下载浏览器驱动" class="headerlink" title="下载浏览器驱动"></a>下载浏览器驱动</h2><img src="/post/6be0da90/image-20240104212952850.png" class="" title="image-20240104212952850">

<p>在设置里查看自己的浏览器版本，我的是<code>Chrome的120.0.6099.200（正式版本） （64 位）</code></p>
<p>打开<a href="https://chromedriver.storage.googleapis.com/index.html">Chrome驱动网页</a> （需要借助一些工具才能到达此页），选择对应的版本，如果没有对应的版本，选择最近的一个版本即可。</p>
<img src="/post/6be0da90/image-20240104214443422.png" class="" title="image-20240104214443422">

<p>点击进入后根据自己的操作系统选择版本，Windows就下载win32版本：</p>
<img src="/post/6be0da90/image-20240104214655855.png" class="" title="image-20240104214655855">

<p>下载好后解压，里面会有一个exe文件，但直接运行不会有什么效果</p>
<img src="/post/6be0da90/image-20240104220717596.png" class="" title="image-20240104220717596">

<p>将这个exe文件放在你的<strong>代码文件目录</strong>下，如果你不想每次都添加到工作目录，可以将这个exe的文件路径添加到环境变量中去。</p>
<p>你也可以选择使用npm来安装，但有几率安装失败</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install chromedriver</span><br></pre></td></tr></table></figure>





<h2 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install selenium-webdriver</span><br></pre></td></tr></table></figure>

<p>等待安装完成，使用下面的代码进行测试，如果能弹出浏览器，说明安装成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入selenium 库</span></span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">Builder</span>, <span class="title class_">By</span>, <span class="title class_">Key</span>, until,<span class="title class_">Button</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;selenium-webdriver&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// require(&#x27;chromedriver&#x27;); 如果是npm安装驱动需要导入chromedriver</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">	<span class="comment">// require(&#x27;chromedriver&#x27;); //导入chrome浏览器 driver，不是npm安装驱动不需要导入chromedriver</span></span><br><span class="line">	<span class="keyword">const</span> driver = <span class="keyword">new</span> <span class="title class_">Builder</span>().<span class="title function_">forBrowser</span>(<span class="string">&#x27;chrome&#x27;</span>).<span class="title function_">build</span>() </span><br><span class="line">	<span class="keyword">await</span> driver.<span class="title function_">get</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">//driver.quit() // 表示关闭浏览器 </span></span><br><span class="line">    <span class="comment">//driver.close() //表示关闭当前窗口</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>这里引入了<strong>selenium</strong>最基础的方法:</p>
<ul>
<li><p><code>Builder</code> 对象：用于设置 WebDriver 的配置。通过 <code>forBrowser()</code> 方法指定浏览器类型，并通过 <code>build()</code> 方法生成 WebDriver 实例。</p>
</li>
<li><p><code>By</code> 对象：用于选择网页中的元素，常用的方法包括 <code>id</code>、<code>name</code>、<code>class</code>、<code>xpath</code>、<code>css</code> 等。</p>
</li>
<li><p><code>Key</code> 对象：表示键盘上的按键，用于模拟键盘操作，如回车键、Tab 键等。</p>
</li>
<li><p><code>until</code> 对象：用于等待某些条件的出现，如等待页面加载完成、等待元素出现等。</p>
</li>
<li><p><code>Button</code> 对象：表示鼠标上的按键，用于模拟鼠标操作，如左键、右键、滚轮等。</p>
<h3 id="更多API"><a href="#更多API" class="headerlink" title="更多API"></a>更多API</h3><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">driver.<span class="title function_">findElement</span>(<span class="title class_">By</span>.<span class="title function_">name</span>(<span class="string">&#x27;btnG&#x27;</span>))；</span><br><span class="line">driver.<span class="title function_">findElement</span>(&#123;<span class="attr">id</span>:<span class="string">&#x27;btnG&#x27;</span>&#125;)；</span><br><span class="line"></span><br><span class="line">findElements <span class="comment">//查找多个元素By.className(classname)</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">css</span>(selector) <span class="comment">//通过 CSS Selector 查找元素</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">id</span>(id)</span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">name</span>(name) <span class="comment">//通过 Name 属性查找元素。</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">linkText</span>(text) <span class="comment">//通过链接文本查找元素。</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">partialLink</span>(text) <span class="comment">//通过部分链接文本查找元素。</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">xpath</span>() <span class="comment">//通过 XPath 查找元素。</span></span><br><span class="line"><span class="title class_">By</span>.<span class="title function_">js</span>() <span class="comment">//通过 JavaScript 查找元素。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">driver.<span class="title function_">getPageSource</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">souce</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(souce);<span class="comment">//获取代码</span></span><br><span class="line"></span><br><span class="line">driver.<span class="title function_">getTitle</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a)&#125;);<span class="comment">//获取网页标题</span></span><br><span class="line"></span><br><span class="line">driver.<span class="title function_">getCurrentUrl</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a)&#125;);<span class="comment">//获取当前url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//element为web元素对象，为findelement()的返回对象element.getText().then(b=&gt;&#123;console.log(“text”,b)&#125;)</span></span><br><span class="line"><span class="comment">//返回里面没有被隐藏的文字（不带标签）</span></span><br><span class="line">element.<span class="title function_">getTagName</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getTagName&#x27;</span>,a)&#125;)</span><br><span class="line"><span class="comment">//返回标签名</span></span><br><span class="line">element.<span class="title function_">getId</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(“<span class="variable constant_">ID</span>”,a)&#125;)</span><br><span class="line"><span class="comment">//返回这个element服务器分配的不透明id</span></span><br><span class="line"></span><br><span class="line">elements.<span class="title function_">getCssValue</span>().<span class="title function_">then</span>(<span class="function"><span class="params">a</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getCssValue&#x27;</span>,a)&#125;)</span><br><span class="line"><span class="comment">//返回该element的CSS属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他属性:element.getAttribute(“class”).then(b=&gt;&#123;console.log(b)&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">driver.<span class="title function_">findElement</span>(&#123;<span class="attr">css</span>:css&#125;).<span class="title function_">click</span>()<span class="comment">//鼠标左键单击</span></span><br><span class="line">driver.<span class="title function_">findElement</span>(&#123;<span class="attr">css</span>:css&#125;).<span class="title function_">clear</span>(); <span class="comment">//清空input</span></span><br><span class="line">driver.<span class="title function_">findElement</span>(&#123;<span class="attr">css</span>:css&#125;).<span class="title function_">sendKeys</span>(<span class="string">&#x27;txt&#x27;</span>);<span class="comment">//输入input</span></span><br><span class="line"></span><br><span class="line">driver.<span class="title function_">takeScreenshot</span>().<span class="title function_">then</span>() <span class="comment">//返回页面png截图</span></span><br><span class="line">driver.<span class="title function_">findElement</span>(&#123;<span class="attr">css</span>:css&#125;).<span class="title function_">takeScreenshot</span>().<span class="title function_">then</span>() <span class="comment">//返回元素png截图</span></span><br><span class="line"></span><br><span class="line">driver.<span class="title function_">excuteScript</span>(<span class="string">&quot;document.getElementByTagName(&#x27;body&#x27;)[0].scrollTop=&#x27;8000&#x27;&quot;</span>)<span class="comment">//窗口滚动条-下拉滚动条操作</span></span><br><span class="line"></span><br><span class="line">driver.<span class="title function_">actions</span>().<span class="title function_">mouseMove</span>(el).<span class="title function_">perform</span>() <span class="comment">//鼠标悬停操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="options对象"><a href="#options对象" class="headerlink" title="options对象"></a>options对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> options = driver.<span class="title function_">manage</span>()<span class="comment">//获得options对象</span></span><br><span class="line"></span><br><span class="line">options.<span class="title function_">addCookie</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">value</span>:<span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">options.<span class="title function_">deleteAllCookies</span>()</span><br><span class="line"></span><br><span class="line">cookiesoptions.<span class="title function_">deleteCookie</span>(name) <span class="comment">//删除所有</span></span><br><span class="line"></span><br><span class="line">options.<span class="title function_">getCookie</span>(name) <span class="comment">//按照name删除</span></span><br><span class="line"></span><br><span class="line">options.<span class="title function_">getCookies</span>() <span class="comment">//拿到name字段的cookie值，为promise对象</span></span><br></pre></td></tr></table></figure>

<h4 id="navigate对象"><a href="#navigate对象" class="headerlink" title="navigate对象"></a>navigate对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nav = driver.<span class="title function_">navigate</span>()<span class="comment">//获得navigate对象</span></span><br><span class="line"><span class="comment">///nav有四个方法分别为：</span></span><br><span class="line">nav.<span class="title function_">back</span>();<span class="comment">//后退</span></span><br><span class="line">nav.<span class="title function_">forward</span>();<span class="comment">//前进</span></span><br><span class="line">nav.<span class="title function_">refresh</span>();<span class="comment">//刷新</span></span><br><span class="line">nav.<span class="title function_">to</span>(url);<span class="comment">//跳转到url</span></span><br></pre></td></tr></table></figure>



<p>下面示例一个打开<strong>bing</strong>自动搜索<strong>壁纸</strong>并<strong>点击截图</strong>的自动化程序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">Builder</span>, <span class="title class_">By</span>, <span class="title class_">Key</span>, until,<span class="title class_">Button</span>,<span class="title class_">Actions</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;selenium-webdriver&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line"><span class="comment">// require(&#x27;chromedriver&#x27;); //导入chrome浏览器 driver，不是npm安装驱动不需要导入chromedriver</span></span><br><span class="line"><span class="comment">//这里我使用的chrome</span></span><br><span class="line">  <span class="keyword">const</span> driver = <span class="keyword">new</span> <span class="title class_">Builder</span>().<span class="title function_">forBrowser</span>(<span class="string">&#x27;chrome&#x27;</span>).<span class="title function_">build</span>() </span><br><span class="line">  <span class="keyword">await</span> driver.<span class="title function_">get</span>(<span class="string">&#x27;https://cn.bing.com/&#x27;</span>) <span class="comment">//想要打开的网址</span></span><br><span class="line">  <span class="keyword">await</span> driver.<span class="title function_">findElement</span>(<span class="title class_">By</span>.<span class="title function_">css</span>(<span class="string">&#x27;#sb_form_q&#x27;</span>)).<span class="title function_">sendKeys</span>(<span class="string">&#x27;bing壁纸4k&#x27;</span>, <span class="title class_">Key</span>.<span class="property">ENTER</span>);<span class="comment">//输入input</span></span><br><span class="line">  <span class="keyword">await</span> driver.<span class="title function_">findElement</span>(<span class="title class_">By</span>.<span class="title function_">css</span>(<span class="string">&#x27;#b-scopeListItem-images&#x27;</span>)).<span class="title function_">click</span>()</span><br><span class="line">  <span class="keyword">await</span> driver.<span class="title function_">findElement</span>(<span class="title class_">By</span>.<span class="title function_">css</span>(<span class="string">&#x27;.img_cont &gt; img:first-child&#x27;</span>)).<span class="title function_">click</span>()</span><br><span class="line">  <span class="keyword">const</span> actions = driver.<span class="title function_">actions</span>(&#123; <span class="attr">bridge</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="keyword">await</span> actions.<span class="title function_">contextClick</span>(<span class="keyword">await</span> driver.<span class="title function_">findElement</span>(<span class="title class_">By</span>.<span class="title function_">css</span>(<span class="string">&#x27;body&#x27;</span>)).<span class="title function_">click</span>()).<span class="title function_">perform</span>(); <span class="comment">// 右键单击</span></span><br><span class="line">  <span class="keyword">const</span> screenshot = <span class="keyword">await</span> driver.<span class="title function_">takeScreenshot</span>(); <span class="comment">// 截图</span></span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;screenshot.png&#x27;</span>, screenshot, <span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 将截图数据写入图片文件</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>





<p>更多的selenium的api可以在他的npm官网找到：<a href="https://www.selenium.dev/selenium/docs/api/javascript/module/selenium-webdriver/">selenium-webdriver</a></p>
<h2 id="selenium应对反爬虫"><a href="#selenium应对反爬虫" class="headerlink" title="selenium应对反爬虫"></a>selenium应对反爬虫</h2><p>大部分网站会有反爬机制，通过cheerio库或者截取html信息无法获取全部信息。且过多的爬虫会被网站封杀ip，selenium能把我们包装成正常访问网站的浏览器用户，帮助我们更好的爬取我们需要的数据。</p>
</li>
</ul>
<h1 id="四、nodejs连接数据库"><a href="#四、nodejs连接数据库" class="headerlink" title="四、nodejs连接数据库"></a>四、nodejs连接数据库</h1><p>爬虫的最终目标的将数据存入数据库，nodejs也提供了相应的模块方便我们操作，以mysql为例</p>
<p>node.js连接数据库需要先安装mysql包<br><code>npm install mysql</code></p>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>, <span class="comment">//主机地址</span></span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;root&quot;</span>,		<span class="comment">//用户名</span></span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="string">&quot;3306&quot;</span>,<span class="comment">//端口号，可选</span></span><br><span class="line">  <span class="attr">database</span>: <span class="string">&quot;mall&quot;</span>  /数据库名</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建与数据库连接的对象</span></span><br><span class="line"><span class="keyword">let</span> con = mysql.<span class="title function_">createConnection</span>(options)</span><br><span class="line">con.<span class="title function_">connect</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接成功&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>封面图片链接</strong>：<a href="https://ts1.cn.mm.bing.net/th/id/R-C.4d20f5962fda5344d5ccd24f617c00fb?rik=o5PglvR6Vg1X0A&riu=http://image.hnol.net/c/2016-10/08/13/201610081352257411-2127595.jpg&ehk=gYdCn243RGotUkh0qzsI08x9U6me0TgcRaAGn9I78jw=&risl=&pid=ImgRaw&r=0">https://ts1.cn.mm.bing.net/th/id/R-C.4d20f5962fda5344d5ccd24f617c00fb?rik=o5PglvR6Vg1X0A&amp;riu=http%3a%2f%2fimage.hnol.net%2fc%2f2016-10%2f08%2f13%2f201610081352257411-2127595.jpg&amp;ehk=gYdCn243RGotUkh0qzsI08x9U6me0TgcRaAGn9I78jw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0</a></p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>promise的使用</title>
    <url>/post/36345c37.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="一、为什么使用Promise"><a href="#一、为什么使用Promise" class="headerlink" title="一、为什么使用Promise?"></a>一、为什么使用Promise?</h1><p>我们知道 js 执行的时候，一次只能执行一个任务，它会阻塞其他任务。由于这个缺陷导致 js 的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以使用回调函数执行。</p>
<p>常见的异步模式有以下几种：</p>
<ul>
<li>定时器</li>
<li>接口调用</li>
<li>事件函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callBack</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行完成&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before setTimeout&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(callBack,<span class="number">1000</span>)<span class="comment">// 1秒后调用callBack函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after setTimeout&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before setTimeout</span><br><span class="line">after setTimeout</span><br><span class="line">执行完成 //1秒后打印</span><br></pre></td></tr></table></figure>



<p>上述定时器是在固定时间触发某个回调函数。</p>
<p>对于 ajax 网络请求就没有这么简单了，可能有多个网络请求是关联的，先执行某个请求返回结果后，第一个返回结果作为第二个请求的参数，调用第二个网络请求。如此，如果业务复杂，网络请求太多时，回调也很多，容易出现回调地狱。所以 Promise 出现了，专门解决异步回调地狱问题。</p>
<p>通俗地讲，Promise 就像一个容器，里面存放着未来才会结束，返回结果的容器，返回的结果只需要在出口处接收就好了。从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<h1 id="二、Promise基本使用"><a href="#二、Promise基本使用" class="headerlink" title="二、Promise基本使用"></a>二、Promise基本使用</h1><p>Promise 实例化的时候，传入的参数是一个函数，函数中接收两个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">//1秒后打印123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>传入的 resolve 和 reject 本身都是函数。其作用分别为：</p>
<p>resolve - 把 Promise 的状态从进行中变为成功状态。</p>
<p>reject - 把 Promise 的状态从进行中变为拒绝状态。</p>
<p><strong>Promise的三种状态：</strong></p>
<p>pending ：进行中，表示 Promise 还在执行阶段，没有执行完成。</p>
<p>fulfilled：成功状态，表示 Promise 成功执行完成。</p>
<p>rejected：拒绝状态，表示 Promise 执行被拒绝，也就是失败。</p>
<p>Promise 的状态，只可能是其中一种状态，从进行中变为成功或失败状态之后，状态就固定了，不会再发生改变。</p>
<p><strong>Promise.then</strong></p>
<p>执行 resolve 时，Promise 状态变为 fulfilled ，会执行 .then 方法。then 方法接收的参数也是一个函数，函数中携带一个参数，该参数是 resolve(res) 返回的数据。</p>
<p><strong>Promise.catch</strong></p>
<p>执行 reject 时，Promise 状态从 pending 变为 rejected，会执行 catch 方法，catch 方法接收的也是一个函数，函数中携带一个参数，该参数为 reject(err) 返回的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//不执行</span></span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err)<span class="comment">//1秒后打印 error message</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="三、Promise-链式调用"><a href="#三、Promise-链式调用" class="headerlink" title="三、Promise 链式调用"></a>三、Promise 链式调用</h1><p>制作一个模拟网络请求：</p>
<ul>
<li>第一次返回 a，</li>
<li>修改返回的结果为 aa，作为第二次网络请求返回的结果。</li>
<li>修改结果为 aaa，作为第三次返回结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res1&#x27;</span>,res) <span class="comment">//1秒后打印 a</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="title function_">resolve</span>(res+<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">   &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res&#x27;</span>,res) <span class="comment">//2秒后打印 aa</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(res+<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res3&#x27;</span>,res) <span class="comment">//3秒后打印 aaa</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种场景其实就是接口的多层嵌套使用，Promise 可以把多层嵌套按照线性的方式进行书写，非常优雅。我们把 Promise 的多层嵌套调用就叫做链式调用。</p>
<p>上述实例，有三层嵌套就 new 了 3 个Promise，代码写得比较多，我们看看在实现功能的前提下如何能够简化。</p>
<h1 id="四、Promise-嵌套使用的简写"><a href="#四、Promise-嵌套使用的简写" class="headerlink" title="四、Promise 嵌套使用的简写"></a>四、Promise 嵌套使用的简写</h1><p>promise传入的函数参数reject是一个非必传的参数，如果不需要处理失败时的结果时，我们可以省略掉 reject 。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化1</span></span><br><span class="line"><span class="keyword">const</span> ppp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res1&#x27;</span>,res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(res+<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(res+<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res3&#x27;</span>,res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 嵌套使用时，内层的 Promise 可以省略不写，所以我们可以直接把 Promise 相关的去掉，只返回最后一个结果返回，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化2</span></span><br><span class="line"><span class="keyword">const</span> pppp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span>  res+<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> res+<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res3&#x27;</span>,res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同理，失败状态catch也能简写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ppppp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="title function_">reject</span>(err+<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写1</span></span><br><span class="line"><span class="keyword">const</span> pppppp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span><span class="title function_">reject</span>(err+<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写2</span></span><br><span class="line"><span class="keyword">const</span> ppppppp = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err+<span class="string">&#x27;a&#x27;</span></span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="五、Promise方法"><a href="#五、Promise方法" class="headerlink" title="五、Promise方法"></a>五、Promise方法</h1><h2 id="all-方法"><a href="#all-方法" class="headerlink" title="all 方法"></a>all 方法</h2><p>Promise.all 方法，提供了并行执行异步操作的能力，并且在所有异步操作完成之后，统一返回所有结果。具体使用如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span><span class="title function_">resolve</span>(<span class="string">&#x27;b&#x27;</span>)),</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all&#x27;</span>,res)<span class="comment">//【&#x27;a&#x27; , &#x27;b&#x27;】</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>控制台输出一个all数组，数组长度取决于 Promise 的个数。</p>
<p>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各类资源，所有的都加载完后，再进行页面的初始化。</p>
<h2 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h2><p>race翻译成中文：赛跑。就是谁跑得最快，谁才能触碰到终点的胜利线。</p>
<p>Promise.race 用法与 all 一样，只是返回结果上不同，它返回的是<strong>执行最快的那个 Promise 的结果</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">   &#125;,<span class="number">100</span>)</span><br><span class="line">  ),</span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">   &#125;,<span class="number">200</span>)</span><br><span class="line">  ),</span><br><span class="line"> ]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;race&#x27;</span>,res) <span class="comment">// 返回 a</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





</font>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>一些前端面试题（一）</title>
    <url>/post/20802113.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<p>记录一点前端面试中会出现的问题</p>
<h1 id="hash-与-history-的区别？"><a href="#hash-与-history-的区别？" class="headerlink" title="hash 与 history 的区别？"></a>hash 与 history 的区别？</h1><h2 id="原理区别"><a href="#原理区别" class="headerlink" title="原理区别"></a>原理区别</h2><h3 id="hash-原理"><a href="#hash-原理" class="headerlink" title="hash 原理"></a><strong>hash 原理</strong></h3><p>hash 通过监听浏览器 onhashchange 事件变化，查找对应路由应用。通过改变 location.hash 改变页面路由。</p>
<h3 id="history-原理"><a href="#history-原理" class="headerlink" title="history 原理"></a><strong>history 原理</strong></h3><p>利用 html5 的history Interface 中新增的 pushState() 和 replaceState() 方法，改变页面路径。</p>
<p>history Interface 是浏览器历史记录栈提供的接口，可通过 back、forward、go 等，可以读取历览器历史记录栈的信息，pushState、repalceState 还可以对浏览器历史记录栈进行修改。</p>
<table>
<thead>
<tr>
<th>hash</th>
<th>history</th>
</tr>
</thead>
<tbody><tr>
<td>有#号</td>
<td>无#号</td>
</tr>
<tr>
<td>能够兼容IE8</td>
<td>只能兼容到IE10</td>
</tr>
<tr>
<td>实际的url之前使用哈希字符，这部分url不会发送到服务器，不需要在服务器层面上进行任何处理</td>
<td>每访问一个页面都需要服务器进行路由匹配生成 html 文件再发送响应给浏览器，消耗服务器大量资源</td>
</tr>
<tr>
<td>刷新不会存在404</td>
<td>浏览器直接访问嵌套路由时，会报 404 问题。</td>
</tr>
<tr>
<td>不需要服务器任何配置</td>
<td>需要在服务器配置一个回调路由</td>
</tr>
</tbody></table>
<h2 id="hash-模式优势"><a href="#hash-模式优势" class="headerlink" title="hash 模式优势"></a>hash 模式优势</h2><p>1、从兼容角度分析。</p>
<p>　　hash 可以兼容到 IE8，而 history 只能兼容到 IE10。</p>
<p>2、从网络请求的角度分析。</p>
<p>　　使用 hash 模式，地址改变时通过 hashchange 事件，只会读取哈希符号后的内容，并不会发起任何网络请求。</p>
<p>　　而 history 模式，每访问一个页面都要发起网络请求，每个请求都需要服务器进行路由匹配、数据库查询、生成HTML文档后再发送响应给浏览器，这个过程会消耗服务器的大量资源，给服务器的压力较大。</p>
<p>3、服务器配置角度分析。</p>
<p>　　hash 不需要服务器任何配置。</p>
<p>　　history 进行刷新页面时，无法找到url对应的页面，会出现 404 问题。因为域名后面的路由是由前端控制的，后端只能保留域名部分，所以就会造成页面丢失的问题，需要服务器端添加一个回退路由，就能解决该问题了。</p>
<h3 id="hash模式的不足"><a href="#hash模式的不足" class="headerlink" title="hash模式的不足"></a><strong>hash模式的不足</strong></h3><p>1、hash 模式中的 # 也称作锚点，这里的的 # 和 css 中的 # 是一个意思，所以在 hash 模式内，页面定位会失效。</p>
<p>2、hash 不利于 SEO（搜索引擎优化）。</p>
<p>3、白屏时间问题。浏览器需要等待 JavaScript 文件加载完成之后渲染 HTML 文档内容，用户等待时间稍长。</p>
<h1 id="什么是-MVVM、mvc-模型？"><a href="#什么是-MVVM、mvc-模型？" class="headerlink" title="什么是 MVVM、mvc 模型？"></a>什么是 MVVM、mvc 模型？</h1><p><strong>MVC:</strong> MVC 即 model-view-controller（模型-视图-控制器)是项目的一种分层架构思想，它把复杂的业务逻辑， 抽离为职能单一的小模块，每个模块看似相互独立，其实又各自有相互依赖关系。它的好处是： 保证了模块的智能单一性，方便程序的开发、维护、耦合度低。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7bdc26eeb745e8a5e0057b8b554d09~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p><strong>MVVM：</strong>MVVM 即 Model-View-ViewModel，(模型-视图-控制器)它是一种双向数据绑定的模式， 用 viewModel 来建立起 model 数据层和 view 视图层的连接，数据改变会影响视图，视图改变会影响数据</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b594cec4834242d582f4598c9db4179c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h1 id="vue-双向数据绑定的原理？"><a href="#vue-双向数据绑定的原理？" class="headerlink" title="vue 双向数据绑定的原理？"></a>vue 双向数据绑定的原理？</h1><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过<strong>Object.defineProperty()**来劫持各个属性的**setter**，</strong>getter**，在数据变动时发布消息给订阅者，触发相应的监听回调。 <strong>具体步骤：</strong></p>
<p><strong>第一步：</strong> 需要 <strong>observe</strong> 的数据对象进行递归遍历，包括子属性对象的属性，都加上 <strong>setter</strong> 和<strong>getter</strong> 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>
<p><strong>第二步：</strong> <strong>compile 解析模板指令</strong>，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p><strong>第三步：</strong> <strong>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁</strong>，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 <strong>update()</strong> 方法 3、待属性变动 <strong>dep.notice()</strong> 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p>
<p>第四步：MVVM 作为数据绑定的入口，整合 <strong>Observer、Compile 和 Watcher</strong> 三者，通过 Observer 来监听自己的 model 数据变化， 通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新； 视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88523a441edf4712a616913bf2d2673b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="vue_02.png"></p>
<h1 id="vue-的生命周期有哪些？"><a href="#vue-的生命周期有哪些？" class="headerlink" title="vue 的生命周期有哪些？"></a>vue 的生命周期有哪些？</h1><h2 id="vue2生命周期"><a href="#vue2生命周期" class="headerlink" title="vue2生命周期"></a>vue2生命周期</h2><ul>
<li><strong>beforeCreat() 创建前</strong> 在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在此生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法</li>
<li><strong>created（）被创建</strong> data 和 methods都已经被初始化好了，可以调用了</li>
<li><strong>beforeMount() 挂载前</strong> 在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的</li>
<li><strong>mounted（）已挂载</strong> Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行</li>
<li><strong>beforeupdate（）更新前</strong> 页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步</li>
<li><strong>updated（）更新</strong> 页面显示的数据和data中的数据已经保持同步了，都是最新的</li>
<li><strong>beforeDestroy() 销毁前</strong> Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁</li>
<li><strong>destroyed（）被销毁</strong> 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。</li>
</ul>
<p><img src="https://cdn.acwing.com/media/article/image/2021/08/06/101476_366b60c2f6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue 生命周期原理图 - AcWing"></p>
<p>除了<code>beforecate</code>和<code>created</code>(它们被<code>setup</code>方法本身所取代)，我们可以在<code>setup</code>方法中访问的API生命周期钩子有9个选项:</p>
<ul>
<li><p><code>onBeforeMount</code> – 在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
</li>
<li><p><code>onMounted</code> – 组件挂载时调用</p>
</li>
<li><p><code>onBeforeUpdate</code> – 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
</li>
<li><p><code>onUpdated</code> – 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
</li>
<li><p>onBeforeUnmount – 在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。</p>
</li>
<li><p><code>onUnmounted</code> – 卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>onActivated</code> – 被 <code>keep-alive</code> 缓存的组件激活时调用。</p>
</li>
<li><p><code>onDeactivated</code> – 被 <code>keep-alive</code> 缓存的组件停用时调用。</p>
</li>
<li><p><code>onErrorCaptured</code> – 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p>
</li>
</ul>
<p><img src="https://lordblog.cn/upload/2021/07/image-8359d1e7177f4ed486c55475a0da06bf.png" alt="Vue3.0"></p>
<h1 id="Vue3-中的setup-在哪一个阶段执行？"><a href="#Vue3-中的setup-在哪一个阶段执行？" class="headerlink" title="Vue3.中的setup()在哪一个阶段执行？"></a>Vue3.中的setup()在哪一个阶段执行？</h1><p>setup是组合api的入口函数。setup()函数在beforecreate()函数执行之前,已经执行。也就是说在setup函数中我们不能够对data和methods进行操作。</p>
<h1 id="v-if-和-v-show-有什么区别？"><a href="#v-if-和-v-show-有什么区别？" class="headerlink" title="v-if 和 v-show 有什么区别？"></a>v-if 和 v-show 有什么区别？</h1><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建， 操作的实际上是 dom 元素的创建或销毁。</p>
<p><code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换， 它操作的是<code>display:none/block</code>属性。</p>
<p>一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常<strong>频繁地切换</strong>，则使用<code> v-show</code> 较好； 如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h1 id="async-await-是什么？它有哪些作用？"><a href="#async-await-是什么？它有哪些作用？" class="headerlink" title="async await 是什么？它有哪些作用？"></a>async await 是什么？它有哪些作用？</h1><p><strong>async await</strong> 是<strong>es7</strong>里面的新语法、它的作用就是 async 用于申明一个 function 是异步的，而 await 用 于等待一个异步方法执行完成。它可以很好的替代<strong>promise 中的 then</strong></p>
<p>async 函数返回一个 Promise 对象，可以使用 <strong>then</strong> 方法添加回调函数。当函数执行的时候，一旦遇 到 <code>await </code>就会先返回， 等到异步操作完成，再接着执行函数体内后面的语句。</p>
<h1 id="常用的数组方法有哪些？"><a href="#常用的数组方法有哪些？" class="headerlink" title="常用的数组方法有哪些？"></a>常用的数组方法有哪些？</h1><p><strong>concat()</strong> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<p><strong>find()</strong> 方法<strong>返回数组中满足提供的测试函数的第一个元素的值</strong>。否则返回 undefined 。</p>
<p><strong>findIndex()</strong> 方法返回数组中满足提供的测试函数的<strong>第一个元素的索引</strong>。否则返回-1。</p>
<p><strong>includes()</strong> 方法用来<strong>判断一个数组是否包含一个指定的值</strong>，根据情况，如果包含则返回 true， 否则返回 false。</p>
<p><strong>indexOf()</strong> 方法返回在数组中可以<strong>找到一个给定元素的第一个索引</strong>，如果<strong>不存在，则返回-1</strong>。 （通常用它判断数组中有没有这个元素）</p>
<p><strong>join()</strong> 方法将一个数组（或一个类数组对象）的所有元素<strong>连接成一个字符串并返回这个字符串</strong>。 如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>
<p><strong>pop()</strong> 方法从数组中<strong>删除最后一个元素</strong>，并返回该元素的值。此方法更改数组的长度。</p>
<p><strong>push()</strong> 方法将<strong>一个或多个元素添加到数组的末尾</strong>，并返回该数组的新长度。</p>
<p><strong>shift()</strong> 方法从数组中<strong>删除第一个元素</strong>，并返回该元素的值。此方法更改数组的长度。</p>
<p><strong>unshift()</strong> 方法将<strong>一个或多个元素添加到数组的开头</strong>，并返回该数组的新长度(该方法修改原有数组)。</p>
<p><strong>splice()</strong> 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内 容。<strong>此方法会改变原数组</strong>。 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删 除元素，则返回空数组。</p>
<p><strong>slice()</strong> 方法同上，但不会改变原数组</p>
<p><strong>reverse()</strong> 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。</p>
<p><strong>sort()</strong> 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字 符串，然后比较它们的 UTF-16 代码单元值序列时构建的</p>
<h1 id="数组有哪几种循环方式？分别有什么作用？"><a href="#数组有哪几种循环方式？分别有什么作用？" class="headerlink" title="数组有哪几种循环方式？分别有什么作用？"></a>数组有哪几种循环方式？分别有什么作用？</h1><p><strong>every()</strong> 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔 值。</p>
<p><strong>filter()</strong> 方法<strong>创建一个新数组</strong>, 其包含通过所提供函数实现的测试的所有元素。 <strong>注意：</strong> filter() 不会对空数组进行检测。 <strong>注意：</strong> filter() 不会改变原始数组。</p>
<p><strong>forEach()</strong> 方法对数组的<strong>每个元素执行一次</strong>提供的函数。</p>
<p><strong>some()</strong> 方法测试<strong>是否至少有一个元素可以通过被提供的函数方法</strong>。该方法返回一个 Boolean 类型 的值。</p>
<h1 id="常用的字符串方法有哪些？"><a href="#常用的字符串方法有哪些？" class="headerlink" title="常用的字符串方法有哪些？"></a>常用的字符串方法有哪些？</h1><p><strong>charAt()</strong> 方法从一个字符串中返回指定的字符。</p>
<p><strong>concat()</strong> 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</p>
<p><strong>includes()</strong> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p>
<p><strong>indexOf()</strong> 方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜 索。如果未找到该值，则返回 -1。 <strong>match()</strong> 方法检索返回一个字符串匹配正则表达式的的结果。</p>
<p><strong>padStart()</strong> 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的 长度。填充从当前字符串的开始(左侧)应用的。 (常用于时间补 0)</p>
<p><strong>replace()</strong> 方法返回一个由替换值（ replacement ）替换一些或所有匹配的模式（ pattern ）后的新 字符串。模式可以是一个字符串或者一个<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>，替换值可以是一个字符串或者一个每次匹配都要 调用的回调函数。 原字符串不会改变。 slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。</p>
<p><strong>split()</strong> 方法使用指定的分隔符字符串将一个 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String">String</a> 对象分割成字符串数组，以将字符串分隔为 子字符串，以确定每个拆分的位置。 <strong>substr()</strong> 方法返回一个字符串中从指定位置开始到指定字符数的字符。 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。</p>
</font>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
        <tag>vue</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序城市定位</title>
    <url>/post/b55f790c.html</url>
    <content><![CDATA[<p>在微信小程序的项目开发中，我们需要定位用户的位置，</p>
<p>而微信小程序内置了可以获取用户经纬度的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&#x27;wgs84&#x27;</span>,</span><br><span class="line"> success (res) &#123;</span><br><span class="line">   <span class="keyword">const</span> latitude = res.<span class="property">latitude</span></span><br><span class="line">   <span class="keyword">const</span> longitude = res.<span class="property">longitude</span></span><br><span class="line">   <span class="keyword">const</span> speed = res.<span class="property">speed</span></span><br><span class="line">   <span class="keyword">const</span> accuracy = res.<span class="property">accuracy</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中<code>latitude</code>和<code>longitude</code>分别是经度和纬度。但是仅凭经纬度无法到达定位城市的效果，必须借助第三方地图商的API，如高德、百度、腾讯等等。</p>
<h1 id="腾讯地图定位城市API"><a href="#腾讯地图定位城市API" class="headerlink" title="腾讯地图定位城市API"></a>腾讯地图定位城市API</h1><p>推荐使用腾讯地图，毕竟跟微信小程序是一家的。</p>
<h2 id="注册腾讯地图API平台"><a href="#注册腾讯地图API平台" class="headerlink" title="注册腾讯地图API平台"></a>注册腾讯地图API平台</h2><p>直接注册就行，注册好后在<code>控制台</code>&#x3D;&gt;<code>应用管理</code>&#x3D;&gt;<code>我的应用</code>里添加一个应用并获取一个<strong>KEY</strong></p>
<p>接下来需要到<code>配额管理</code>中分配额度，个人用户每天有<strong>5000</strong>条api请求额度，需要分配到不同的请求单位，不然每天只能请求一次</p>
<img src="/post/b55f790c/image-20240122155009941.png" class="" title="image-20240122155009941">

<p>这里我把全部额度分配给了IP定位，因为我暂时只使用这一个API模块</p>
<h2 id="IP定位接口"><a href="#IP定位接口" class="headerlink" title="IP定位接口"></a>IP定位接口</h2><p>城市定位是最简单的一个API，就是一个简单的<strong>GET</strong>请求</p>
<p>url:<font color=Blue><strong><a href="https://apis.map.qq.com/ws/location/v1/ip">https://apis.map.qq.com/ws/location/v1/ip</a></strong></font></p>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">必填</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">key</td>
<td align="left">是</td>
<td align="left">开发密钥（Key）</td>
<td align="left">key&#x3D;OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-*****</td>
</tr>
<tr>
<td align="left">ip</td>
<td align="left">否</td>
<td align="left">IP地址，缺省时会使用请求端的IP</td>
<td align="left">ip&#x3D;111.206.145.41</td>
</tr>
<tr>
<td align="left">output</td>
<td align="left">否</td>
<td align="left">返回格式：支持JSON&#x2F;JSONP，默认JSON</td>
<td align="left">output&#x3D;json</td>
</tr>
<tr>
<td align="left">callback</td>
<td align="left">否</td>
<td align="left">JSONP方式回调函数</td>
<td align="left">callback&#x3D;function1</td>
</tr>
</tbody></table>
<h2 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">必有</th>
<th align="left">说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">status</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">状态码，0为正常，其它为异常，详细请参阅<a href="https://lbs.qq.com/service/webService/webServiceGuide/status">状态码说明</a></td>
<td></td>
</tr>
<tr>
<td align="left">message</td>
<td align="left">string</td>
<td align="left">是</td>
<td align="left">对status的描述</td>
<td></td>
</tr>
<tr>
<td align="left">result</td>
<td align="left">object</td>
<td align="left">是</td>
<td align="left">IP定位结果</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">ip</td>
<td align="left">string</td>
<td align="left">是</td>
<td>用于定位的IP地址</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">object</td>
<td align="left">是</td>
<td align="left">定位坐标。<strong>注：</strong>IP定位服务精确到市级，该位置为IP地址所属的行政区划政府坐标。</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">lat</td>
<td align="left">number</td>
<td align="left">是</td>
<td>纬度</td>
</tr>
<tr>
<td align="left">lng</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">经度</td>
<td></td>
</tr>
<tr>
<td align="left">ad_info</td>
<td align="left">object</td>
<td align="left">是</td>
<td align="left">定位行政区划信息</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">nation</td>
<td align="left">string</td>
<td align="left">是</td>
<td>国家</td>
</tr>
<tr>
<td align="left">nation_code</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">国家代码（ISO3166标准3位数字码）</td>
<td></td>
</tr>
<tr>
<td align="left">province</td>
<td align="left">string</td>
<td align="left">是</td>
<td align="left">省</td>
<td></td>
</tr>
<tr>
<td align="left">city</td>
<td align="left">string</td>
<td align="left">否</td>
<td align="left">市</td>
<td></td>
</tr>
<tr>
<td align="left">district</td>
<td align="left">string</td>
<td align="left">否</td>
<td align="left">区</td>
<td></td>
</tr>
<tr>
<td align="left">adcode</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">行政区划代码</td>
<td></td>
</tr>
</tbody></table>
<h2 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h2><p>GET请求，注意参数值要进行URL编码<br><a href="https://apis.map.qq.com/ws/location/v1/ip?ip=111.206.145.41&key=%5B%E4%BD%A0%E7%9A%84key%5D">https://apis.map.qq.com/ws/location/v1/ip?ip=111.206.145.41&amp;key=[你的key]</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应示例：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Success&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;111.206.145.41&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">39.90469</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;lng&quot;</span><span class="punctuation">:</span> <span class="number">116.40717</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ad_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;nation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;district&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;adcode&quot;</span><span class="punctuation">:</span> <span class="number">110000</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="微信小程序中的使用"><a href="#微信小程序中的使用" class="headerlink" title="微信小程序中的使用"></a>微信小程序中的使用</h2><p>有了第三方api接口，我们就不需要再用内置方法获取经纬度了，但需要注意在微信小程序管理平台上将域名添加上，否则可能获取失败</p>
<img src="/post/b55f790c/image-20240122155835078.png" class="" title="image-20240122155835078">

<p>此外，还需要在<code>app.json</code>中加上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;permission&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;scope.userLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;desc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你的位置信息将用于小程序位置接口的效果展示&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>来获取用户授权定位</p>
<p>示例代码：</p>
<p><code>map.wxml</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;primary&quot;</span> bindtap=<span class="string">&quot;getLocation&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;btn&quot;</span>&gt;定位&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><code>map.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getLocation</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&#x27;https://apis.map.qq.com/ws/location/v1/ip?key=PENBZ-C7WK5-C5UIF-IDZWF-ZR6KV-M6BLQ&#x27;</span>,</span><br><span class="line">            <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>.<span class="property">result</span>.<span class="property">ad_info</span>.<span class="property">city</span>); </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>点击按钮即可获取当前城市名字</p>
<div class="note danger modern"><p>注意：当前版本的开发者工具需要安装第三方腾讯插件才能将res打印到控制台上，如果没有安装插件，只能在真机调试中打印查看</p>
</div>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>第三方API</tag>
      </tags>
  </entry>
  <entry>
    <title>一些前端面试题（二）</title>
    <url>/post/9e4b7ff2.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h1><p>每一个实例对象上有一个<strong>proto 属性</strong>，指向的<strong>构造函数的原型对象</strong>，构造函数的原型 对象也是一个对象， 也有 proto 属性，这样一层一层往上找的过程就形成了<strong>原型链</strong>。</p>
<p><strong>实例对象</strong>的 <strong>proto</strong> 指向构造函数的 prototype，<strong>构造函数</strong>的__proto__ 指向Object的 prototype，<strong>Object</strong>的__proto__ 最终指向null</p>
<p><strong>Javascript中任意数据都能沿着自己的原型链最终找到Object.prototype</strong></p>
<h1 id="什么是闭包？-闭包有哪些优缺点？"><a href="#什么是闭包？-闭包有哪些优缺点？" class="headerlink" title="什么是闭包？ 闭包有哪些优缺点？"></a>什么是闭包？ 闭包有哪些优缺点？</h1><p><strong>闭包</strong>（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个<strong>作用 域可以访问另外一个函数内部的局部变量</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fun</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">fn</span>()</span><br><span class="line"><span class="title function_">f</span>()</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong> 延长变量作用域、在函数的外部可以访问函数内部的局部变量，<strong>容易造成内层泄露</strong>，因为闭包中 的局部变量<strong>永远不会被回收</strong></p>
<h1 id="常见的继承有哪些？"><a href="#常见的继承有哪些？" class="headerlink" title="常见的继承有哪些？"></a>常见的继承有哪些？</h1><h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p><strong>特点：</strong> 1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新 实例不会继承父类实例的属性！</p>
<p><strong>缺点：</strong> 1、新实例无法向父类构造函数传参。</p>
<p>2、继承单一。</p>
<p>3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属 性，另一个实例的原 型属性也会被修改！）</p>
<h2 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h2><p><strong>重点：</strong> 用 <strong>.call()和.apply()</strong> 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复 制））</p>
<p><strong>特点：</strong> 1、只继承了父类构造函数的属性，没有继承父类原型的属性。</p>
<p>2、解决了原型链继承缺点 1、2、3。</p>
<p>3、可以继承多个构造函数属性（call 多个）。</p>
<p>4、在子实例中可向父实例传参。</p>
<p><strong>缺点：</strong> 1、只能继承父类构造函数的属性。</p>
<p>2、无法实现构造函数的复用。（每次用每次都要重新调用）</p>
<p>3、每个新实例都有父类构造函数的副本，臃肿。</p>
<h2 id="三、组合继承（组合原型链继承和借用构造函数继承）（常用）"><a href="#三、组合继承（组合原型链继承和借用构造函数继承）（常用）" class="headerlink" title="三、组合继承（组合原型链继承和借用构造函数继承）（常用）"></a>三、组合继承（组合原型链继承和借用构造函数继承）（常用）</h2><p><strong>重点：</strong> 结合了两种模式的优点，传参和复用</p>
<p><strong>特点：</strong> 1、可以继承父类原型上的属性，可以传参，可复用。</p>
<p>2、每个新实例引入的构造函数属性是私有的。</p>
<p><strong>缺点：</strong> 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函 数。</p>
<h2 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h2><p><strong>重点：</strong> 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的 实例或对象。object.create()就是这个原理。</p>
<p><strong>特点：</strong> 类似于复制一个对象，用函数来包装。</p>
<p><strong>缺点：</strong> 1、所有实例都会继承原型上的属性。 2、无法实现复用。（新实例属性都是后面添加的）</p>
<h2 id="五、class-类实现继承"><a href="#五、class-类实现继承" class="headerlink" title="五、class 类实现继承"></a>五、class 类实现继承</h2><p>通过 extends 和 super 实现继承</p>
<h2 id="六、寄生式继承"><a href="#六、寄生式继承" class="headerlink" title="六、寄生式继承"></a>六、寄生式继承</h2><p><strong>重点：</strong> 就是给原型式继承外面套了个壳子。</p>
<p><strong>优点：</strong> 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成 了创建的新对象。</p>
<p><strong>缺点：</strong> 没用到原型，无法复用。</p>
<h1 id="后台管理系统中的权限管理是怎么实现的？"><a href="#后台管理系统中的权限管理是怎么实现的？" class="headerlink" title="后台管理系统中的权限管理是怎么实现的？"></a>后台管理系统中的权限管理是怎么实现的？</h1><p>登录成功后，服务端会返回一个 <strong>token</strong>（该 token 的是一个能唯一标示用户身份的一个 key），之后我 们将 token 存储在本地 cookie 之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不 用再去登录页面重新登录了。</p>
<p>用户登录成功之后，在全局钩子 router.beforeEach 中拦截路由，判断是否已获得 token，在 获得 token 之后我们就要去获取用户的基本信息了 页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有 token, 就会把这个 token 返给后端去拉取 user_info，保证用户信息是最新的。 当然如果是做了单点登录得功 能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登 录获取最新的内容。</p>
<h1 id="es6-有哪些新特性？"><a href="#es6-有哪些新特性？" class="headerlink" title="es6 有哪些新特性？"></a>es6 有哪些新特性？</h1><p>ES6 是 2015 年推出的一个新的版本、这个版本相对于 ES5 的语法做了很多的优化、例如：新增了<strong>let、 const</strong></p>
<p><strong>let 和 const</strong>具有块级作用域，<strong>不存在变量提升的问题</strong>。新增了<strong>箭头函数</strong>，简化了定义函数的写法，</p>
<p>同时 可以<strong>巧用箭头函数的 this</strong>、（注意箭头函数本身没有 this,它的 this 取决于外部的环境），</p>
<p>新增了<strong>promise</strong> 解决了回调地域的问题，新增了模块化、利用 import 、export 来实现导入、导出。</p>
<p>新增了<strong>结构赋值</strong>， ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</p>
<p>新增了<strong>class 类</strong>的概念，它类似于对象。</p>
<h1 id="v-for-循环为什么一定要绑定-key"><a href="#v-for-循环为什么一定要绑定-key" class="headerlink" title="v-for 循环为什么一定要绑定 key ?"></a>v-for 循环为什么一定要绑定 key ?</h1><p><strong>页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象),</strong> 循环中 ,如果没有唯一 key , 页面上删除 一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为 x 标签被删除 掉, 只需要把渲染的 dom 为 x 的标签去掉即可!</p>
<h1 id="平时都是用什么实现跨域的？"><a href="#平时都是用什么实现跨域的？" class="headerlink" title="平时都是用什么实现跨域的？"></a>平时都是用什么实现跨域的？</h1><p><strong>jsonp:</strong> 利用 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一 定需要对方的服务器做支持才可以。</p>
<p>JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具 有局限性,不安全可能会遭受 XSS 攻击。</p>
<p>声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获 取目标数据(服务器返回的 data)。 创建一个 <code>&lt;script&gt;</code> 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服 务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</p>
<p>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符 串,例如：传递进去的函数名是 show，它准备好的数据是 show(‘我不爱你’) 。</p>
<p>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数 （show），对返回的数据进行操作。</p>
<p><strong>CORS：跨域资源共享（CORS）是一种机制</strong>；当一个资源访问到另外一个资源(这个资源放在 不同的域名或者不同的协议或者端口)，资源就会发起一个跨域的 HTTP 请求需要浏览器和服务器同时支持；</p>
<p>1.整个 CORS 通信，都是浏览器自动完成。浏览器发现了 AJAX 请求跨源，就会自动添加一些附加的头 信息，有时还会多出一次附加的请求，但用户不会有感觉；</p>
<p>2.实现 CORS 的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信</p>
<p>3.服务器对于不同的请求，处理方式不一样； 有简单请求和非简单请求</p>
<h1 id="cookie-、localstorage-、-sessionstrorage-之间有什么区别？"><a href="#cookie-、localstorage-、-sessionstrorage-之间有什么区别？" class="headerlink" title="cookie 、localstorage 、 sessionstrorage 之间有什么区别？"></a>cookie 、localstorage 、 sessionstrorage 之间有什么区别？</h1><ul>
<li>与服务器交互：<ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）</li>
<li>cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存</li>
</ul>
</li>
<li>存储大小：</li>
<li>cookie 数据根据不同浏览器限制，大小一般不能超过 4k</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大</li>
<li>有期时间：<ul>
<li>ocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie 设置的 cookie 过期时间之前一直有效，与浏览器是否关闭无关</li>
</ul>
</li>
</ul>
<h1 id="this-的指向有哪些？"><a href="#this-的指向有哪些？" class="headerlink" title="this 的指向有哪些？"></a>this 的指向有哪些？</h1><p>1、普通函数中的 this 指向 window</p>
<p>2、定时器中的 this 指向 window</p>
<p>3、箭头函数没有 this,它的 this 指向取决于外部环境、</p>
<p>4、事件中的 this 指向事件的调用者 黑马程序员</p>
<p>5、 构造函数中 this 和原型对象中的 this,都是指向构造函数 new 出来实例对象</p>
<p>6、类 class 中的 this 指向由 constructor 构造器 new 出来的实例对象</p>
<p>7、自调用函数中的 this 指向 window</p>
<h1 id="谈谈你平时都用了哪些方法进行性能优化？"><a href="#谈谈你平时都用了哪些方法进行性能优化？" class="headerlink" title="谈谈你平时都用了哪些方法进行性能优化？"></a>谈谈你平时都用了哪些方法进行性能优化？</h1><p><strong>减少 http 请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN 加载包。</strong></p>
</font>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数的特点</title>
    <url>/post/4d1c757e.html</url>
    <content><![CDATA[<font face="ZhuZiAWan" size=3>

<h1 id="箭头函数的使用"><a href="#箭头函数的使用" class="headerlink" title="箭头函数的使用"></a>箭头函数的使用</h1><h2 id="简写方法速记"><a href="#简写方法速记" class="headerlink" title="简写方法速记"></a>简写方法速记</h2><div class="note none blue flat"><p>将原函数的“function”关键字和函数名都删掉，并使用“&#x3D;&gt;”连接参数列表和函数体。</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简写为：</span></span><br><span class="line">(a,b)=&gt;&#123;<span class="comment">//删掉了function和函数名</span></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简写为：</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">add</span> = (<span class="params">a,b</span>)=&gt;&#123; <span class="comment">//删掉了function</span></span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="箭头函数的书写规则"><a href="#箭头函数的书写规则" class="headerlink" title="箭头函数的书写规则"></a>箭头函数的书写规则</h1><h2 id="箭头函数的书写-x3D-gt"><a href="#箭头函数的书写-x3D-gt" class="headerlink" title="箭头函数的书写 ()&#x3D;&gt;{}"></a><strong>箭头函数的书写 ()&#x3D;&gt;{}</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = (<span class="params">zjcopy</span>) =&gt; &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(zjcopy) </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;hello&#x27;</span>) </span><br></pre></td></tr></table></figure>

<h2 id="箭头函数简写规则："><a href="#箭头函数简写规则：" class="headerlink" title="箭头函数简写规则："></a>箭头函数简写规则：</h2><p><strong>（1）箭头函数只能用赋值式写法，不能用声明式写法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = a =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）如果函数体只有一句话，可以省略函数体大括号</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = a =&gt; <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p><strong>（4）箭头函数返回对象时，省略大括号，用小括号括起来。</strong></p>
<p>箭头后面return的是一个对象时, 需要使用({});</p>
<p><strong>（5）如果函数体只有一句话，并且这一句话是return 返回值 那return也可以要省略</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = a =&gt; a</span><br><span class="line"><span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>





<h1 id="箭头函数的特点"><a href="#箭头函数的特点" class="headerlink" title="箭头函数的特点"></a>箭头函数的特点</h1><p><strong>1.箭头函数没有自己的this，arguments，super或new.target</strong></p>
<p><strong>2.箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this。</strong></p>
<div class="note danger flat"><p>这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。</p>
</div>

<p><strong>3. 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误。</strong></p>
<p><strong>4. 箭头函数不绑定arguments，取而代之用rest参数解决，同时没有super和new.target。</strong></p>
<div class="note danger flat"><p>箭头函数没有arguments、super、new.target的绑定，这些值由外围最近一层非箭头函数决定。</p>
</div>

<div class="note danger flat"><p><strong>外围最近一层非箭头函数</strong>指的是箭头函数被包裹在一个普通函数中</p>
</div>

<p><strong>5.箭头函数可以通过拓展运算符获取传入的参数。</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597888ee749b49a69385e687abd57173~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<p><strong>6. 使用call,apply,bind并不会改变箭头函数中的this指向。</strong></p>
<ul>
<li>当对箭头函数使用call或apply方法时，只会传入参数并调用函数，并不会改变箭头函数中this的指向。</li>
<li>当对箭头函数使用bind方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的this指向。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;window_name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">f2</span> = (<span class="params"></span>) =&gt; <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;obj_name&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">call</span>(obj));  <span class="comment">//obj_name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">call</span>(obj));  <span class="comment">// window_name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">apply</span>(obj)); <span class="comment">// obj_name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">apply</span>(obj)); <span class="comment">// window_name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">bind</span>(obj)());  <span class="comment">// obj_name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">bind</span>(obj)());  <span class="comment">// window_name</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 箭头函数没有原型对象prototype这个属性</strong></p>
<div class="note danger flat"><p>由于不可以通过new关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype这个属性。</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">F</span> = (<span class="params"></span>)=&gt;&#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>8. 不能使用yield关键字，不能用作Generator函数</strong></p>
<h1 id="arguments函数"><a href="#arguments函数" class="headerlink" title="arguments函数"></a>arguments函数</h1><h2 id="arguments有什么用？"><a href="#arguments有什么用？" class="headerlink" title="arguments有什么用？"></a>arguments有什么用？</h2><p>arguments对象是所有非箭头函数中都可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此对象包含传递给函数的每一个参数，第一个参数在索引0的位置。</p>
<h2 id="如何将arguments对象转换为数组"><a href="#如何将arguments对象转换为数组" class="headerlink" title="如何将arguments对象转换为数组"></a>如何将arguments对象转换为数组</h2><ol>
<li>通过slice</li>
<li>通过拓展运算符</li>
<li>通过Array.from</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">js</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"><span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br></pre></td></tr></table></figure>

<h2 id="arguments函数如何调用自身函数？"><a href="#arguments函数如何调用自身函数？" class="headerlink" title="arguments函数如何调用自身函数？"></a>arguments函数如何调用自身函数？</h2><div class="note danger flat"><p>我们先看看下面这个函数，这个是可以正常运行的。</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span> (n) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : <span class="title function_">factorial</span>(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(factorial);</span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p>但是作为匿名函数则不行。</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : <span class="comment">/* what goes here? */</span> (n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p>因此arguments.callee诞生了。</p>
</div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(n &gt; <span class="number">1</span>) ? <span class="number">1</span> : <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<div class="note danger flat"><p>所以arguments要想调用自身的匿名函数，可以通过arguments.callee来调用。</p>
</div>

</font>
]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
</search>
